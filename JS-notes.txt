
Lab:
Javascript Runtime:

Browser:
 has embeded javascript runtime/engine/vm

Standalone:
 Node.js 

IDE
 Microsoft vs code

///////////////////////////////

Project setup:
.............


1.select workspace

c:\session\astro\2021\

2.create project folder

c:\session\astro\2021\ js-apps\src

3.lanuch project

c:\session\astro\2021\ js-apps\src\ code .

..........................................................................................
                                        Javascript


What is Javascript?

 The javascript is programming language.

Style of javascript

 standalone styles - inital java - before java 8 -  object oriented programming language
 hybrid styles - mixing many styles in one place.java 8  hybrid style language

javascript was designed as hybrid programming language.
 
javascript supports "functional style","Object based","Event driven" .

History of javascript programming:
..................................

1989 - Web Project was started    -------Sun created Java

1990 -  The first webserver,Browser was created

1994 - Netscap started

1995 - The first netscap navigator came to access web pages 

1996 - Netscap decided to put java inside webbrowser.

----Static web----- only hand coded html pages.

1996 - CREATED Dynamic web : how to work with databases
     - CGI - C,perl.
 J2EE- Servlets,JSP
 MS  - ASP
 OPEN SOURCE - PHP.

 Server side web : create html pages on fly by including data from databases.

Netscap decided to build client side web technoloy- once html is rendered into web browser
how to change that html onfly. 

Netscap decided to create a new programming language, who recurited Brendan Eich
,the programmer , asked to create new programming language for netscap navigator.

-Objective of Project

-It should be like java but it should not be java -light weight - scripting
-deadline is 10 days.

Time line:

1.javascript project started 1995

1.first name of the language was "Mocha"
2.language was renamed to "Live Script" -1996
3.language was renamed to "java Script" -1996



After language ready, which was submitted to standard body "ECMA international"

1996---1997 : JS 1.0 =>ES 1.0

1997- 1998 :  ES 2.0: It did not come

1999 :  ES 3

2007 : ES 4

2008 : ES 5

2012-2015 : ES 6

2016  ONWARDS : es 7,es 8, ......

//////////////////////////////////////////////////////////////////////////////////////////


...........................................................................................

Compilation,Execution, Runtime:
...............................

Javascript has no independant compiler like c++/java.

Runtime: 

 It is program, written in c / c++ , any language.
 Runtime is abstraction/communication layer between os and application programms.

Types of runtime:

1.embeded runtime
  embeded into another software
 eg:
   embeded game engines...
   browsers has lot of embbeded 

   webservers which running java code : tomcat

2.standalone runtime
  which is avaiable separatly
  JVM


Javascript runtime:
...................
 it is avaiable in both mode.

Embeded mode:
  js runtime is avaiable inside every browser.

chrome : V8 
firefox : Spider Monkey
ms : chakra .

standalone mode:
  node js, which has standalone js runtime.
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

Does javascript code is compiled?

 Yes! , inside javascript runtime, which has embbeded compiler.
////////////////////////////////////////////////////////////////////////////////////////////

We are going to use v8:
  "V8 is Google’s open source high-performance JavaScript and WebAssembly engine, written in C++. 
It is used in Chrome and in Node.js, 
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
Where is javascript ? what type of applications we can build using javascript?

1.javascript was created for browser only to process web documents.

Now a days  javascript is used every where.

1. javascript is in server side market : for build Webapps,webservices :Node.js
2. javascript is in mobility  : build mobile applications
3. javascript is in IOT : build any device specific applications.
/////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////

Java Script Programming language: ES 5 AND ES 6
...............................................

1.language fundamentals
2.functional programming
3.Object based programming
4.Browser specific features
   DOM,AJAX.

Node Js:
   Build Nonblocking IO applications 

/////////////////////////////////////////////////////////////////////////////////////////

language fundamentals:

1.type system
2.variables
3.values-literals
4.operators
5.conditional and iterators


Helloworld

index.js

how to run code?

1.via browser

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=<device-width>, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="src/index.js"></script>
</body>
</html>

2.via node platform

$node src/index.js
///////////////////////////////////////////////////////////////////////////////////////////

Javascript is dynamic language:
 during runtime we can modify code.

Type system:

 How to represent data 

Strongly/Static typed languages

 The variable is verfied by the compiler during compile time

eg:
  int a =10;

  a ="hello" ; compiler will show error.

eg: c,c++,java,c#

Weakly/Dynamic typed languages


  The variable type is verifed by the runtime during execution

   def/var(keyword) variableName=value

 eg:
   var a =10;
   a="hello"
  it is perfectly valid

eg:
 js
/////////////////////////////////////////////////////////////////////////////////////////////

How to declare variables?

ES 5

var
Declares a variable, optionally initializing it to a value.

ES 6
let
Declares a block-scoped, local variable, optionally initializing it to a value.
const
Declares a block-scoped, read-only named constant.

this 
  keyword used to declare instance variables(objects)


syntax:

 keyword(var/let/const/this) variableName = value(literal)
 

//how to declare variable

var firstName="Subramanian";
console.log("First Name" + firstName);


literals : values based on it only the type of variable is identified during runtime.

literals types:

1.string
2.number
3.boolean
4.undefined
5.NaN
6.infinity
7.function
8.null
9.object

 var : is used in es 5
 let and const is used in es 6
 this : both version



Note: 
1.var,let,const all are same only but there are few differences, to be disucssed latter.
 var vs let and const.

2.In js ; is optional 


Point:

  if you are building javascript application based on es 6, recommandation is use "let and
const" always.

1.strings:

1.16 bit unicode charaters.

2.strings can be declared inside  "" or ''  or ``(back-tick) es 6 feature
   "" : inspired from java and c++
   '' : js specific notation.
  
3.string concatnation can be done
   +  and , and `foo ${variableName}`
//strings

var firstName = "Subramanian"
var lastName = 'Murugan';

console.log(" Name " + firstName + " " + lastName);
console.log(" Name ", firstName, " ", lastName);

//es 6 concatation syntax. `${variableName}` - interpolation

console.log(`Name ${firstName} ${lastName} `)

//Roles of `` notation : string concation,multi line string litreal.

var title = 'Game Portal'

var htmlDoc = "<html>" +
    "<head><title>" +
    title +
    "</title>" +
    "</head>" +
    "<body><h1>Sony Digital</h1>" +
    "</body></html>";
console.log(htmlDoc);

var newHtmlDoc = `
    <html>
      <head>
        <title>${title}</title>
    </head>
    <body><h1>Astro Gaming Site</h1>
    </body></html>
`;
console.log(newHtmlDoc);
//////////////////////////////////////////////////////////////////////////////////////////////

Numbers:

1.number size is 64 bit by default aka double.
2.It is IEEE 754 Standard.
//numbers

var qty = 10;
var price=1000000000000000000000000000;
console.log(`Qty ${qty}`);
console.log(`Price ${price}`)


Booleans:

1.represents true or false 
2.1 bit value.

//boolean

var isEnabled =true;
var isWorking=false;

console.log(`Enabled ${isEnabled}`)
console.log(`Isworking ${isWorking} `);



undefined:
..........
It is value, assigned to a variable, if no valid literal is assigned.


var firstName;
var price;
var qty;
console.log(`First Name ${firstName}`);
console.log(`price ${price} ${qty}`);

///////////////////////////////////////////////////////////////////////////////////////////

Related to Numbers:

1.NaN :Not a Number 

Not a Number but is number.
NaN represents error code.
NaN error code will come due to "numerical compuation failures".

Note:

 if you get NaN as out put, it is danger/toxic , it is runtime error, you need to fix.


When NaN will come?
 
//NaN use case 1; if you do numerical compuation against undefined

var qty; //undefined
var price = 1000;

var totalPrice = qty * price;
console.log(`Qty ${qty} price ${price} Total Price ${totalPrice}`)


Type conversion : string to number

types of Type conversion

1.implicit Type conversion
 js automatically converts string to number
2.explicit Type conversion
 js uses conversion utility apis to convert string to number.

//NAN

var qty; //undefined
var price = 1000;

var totalPrice = qty * price;
console.log(`Qty ${qty} price ${price} Total Price ${totalPrice}`)
//Type conversion

var count = "10"; // it string type but value is numerical value

//Type conversion happened here; implicit conversion
var totalCount = count * 10;
console.log(`Total Count ${totalCount}`);

//Type conversion using js built in api.
//double(64 bit) to 32 bit(integer)
var totalCounter = parseInt(count) * 10;
console.log(`Total Count ${totalCounter}`);
var totalCounterdouble = parseFloat(count,16) * 10;
console.log(`Total Count ${totalCounterdouble}`);


//Nan and type conversion
// here $100 is not numerical so during type conversion, error is thrown.
var stockValue = "$100";
var totalStock  = parseInt(stockValue) * 100;
console.log(`Total Stock ${totalStock}`);


2.infinity
div by 0


var price = 1000;
var avgPrice = price / 0;
//Avg Price Infinity
console.log(`Avg Price ${avgPrice}`);

////////////////////////////////////////////////////////////////////////////////////////////
Advanced booleans:
  
js supports booleans with value of true / false

In js every thing is true expect the following values.

Falsy Values:

1.boolean false
2.0
3.undefined
4.empty string "",''
5.NaN
6.null



//Advanced boolean

var firstName = "Subramaian";

if (firstName) {
    console.log("firstName found")
} else {
    console.log("firstName not found")
}
var lastName = "";

if (lastName) {
    console.log("lastName found")
} else {
    console.log("lastName not found")
}

var age = 18;

if (age) {
    console.log("age found")
} else {
    console.log("age not found")
}

var count = 0;

if (count) {
    console.log("count found")
} else {
    console.log("count not found")
}


var price;

if (price) {
    console.log("price found")
} else {
    console.log("price not found")
}


var totalPrice = price *100;

if (totalPrice) {
    console.log("totalPrice found")
} else {
    console.log("totalPrice not found")
}
/////////////////////////////////////////////////////////////////////////////////////////////

type of operator:
.................

1.returns type of variable in string format, in a smaller case

  "string","numbers"


//type of operator

var str = "hello";
var n = 100;
var u;
var b = true;
var notanumber = n * u;
var avg = 100 / 0;
//object ,null,function types to be discussed later.

console.log(`type of str ${typeof str}`)
console.log(`type of n ${typeof n}`)
console.log(`type of b ${typeof b}`)
console.log(`type of u ${typeof u}`)
console.log(`type of notanumber ${typeof notanumber}`)
console.log(`type of avg ${typeof avg}`)
///////////////////////////////////////////////////////////////////////////////////////////

Operators:

Assignment operators
Comparison operators
Arithmetic operators
Bitwise operators
Logical operators
String operators
Conditional (ternary) operator
Comma operator
Unary operators
Relational operators

///////////////////////////////////////////////////////////////////////////////////////////

Assignement

Assignment	x = y	   x = y

Addition assignment	x += y	x = x + y
Subtraction assignment	x -= y	x = x - y
Multiplication assignment	x *= y	x = x * y
Division assignment	x /= y	x = x / y
Remainder assignment	x %= y	x = x % y
Exponentiation assignment	x **= y	x = x ** y
Left shift assignment	x <<= y	x = x << y
Right shift assignment	x >>= y	x = x >> y
Unsigned right shift assignment	x >>>= y	x = x >>> y
Bitwise AND assignment	x &= y	x = x & y
Bitwise XOR assignment	x ^= y	x = x ^ y
Bitwise OR assignment	x |= y	x = x | y
Logical AND assignment	x &&= y	x && (x = y)
Logical OR assignment	x ||= y	x || (x = y)
Logical nullish assignment	x ??= y	x ?? (x = y)

//assignment operator

var x = 10;
var y = x;
console.log(`x ${x} y ${y}`);

var myvar = 10;
console.log(`Myvar value is ${myvar} and its type is ${typeof myvar}`)
//reassingment/ re initalization
myvar = "Hello"
console.log(`Myvar value is ${myvar} and its type is ${typeof myvar}`)

var a = 100;
var b = 100;
var c = a + b;
console.log(`C value is ${c}`)
var d = 10;
d = d + 1;
console.log(`d value is ${d}`)
d += 1
console.log(`d value is ${d}`)

///////////////////////////////////////////////////////////////////////////////////////////

Arthimetic Operators;
.....................

numerical operators
 +,-,*,/,%
 ++,--,
 ** - exponent

//arthimetic 

var x = 100;
var y = 100;
console.log(x + y)
console.log(x - y)
console.log(x * y)
console.log(x / y)
console.log(x % y)
console.log(x ** 2)

Bitwise operators and shift operators:
Note : not recommend to overuse in js, js need to convert 64 bit to 32 bit and starts operations.

Logical operators:
...................

Logical AND (&&)

expr1 && expr2	Returns expr1 if it can be converted to false; otherwise, returns expr2. Thus, when used with Boolean values, && returns true if both operands are true; otherwise, returns false.

Logical OR (||)	expr1 || expr2	Returns expr1 if it can be converted to true; otherwise, returns expr2. Thus, when used with Boolean values, || returns true if either operand is true; if both are false, returns false.

Logical NOT (!)	!expr	Returns false if its single operand that can be converted to true; otherwise, returns true.

Logical !! -  keeps the same value.

//logical operators
//
//|| or - based on boolean truth table

var isWorking = true;
var isEnabled = false;
var res = isWorking || isEnabled;
console.log(res);
//advanced or operator.

var name = "Subramaian";

/**
 * if first operand(name) is truthy, then result is first operand itself else
 * second operand
 */

var message = name || "Sorry";

console.log(message);

var price = 0;
var todayMinPrice = price || 10;

console.log(todayMinPrice);
///////////////////////////////////////////////////////////////////////////////
//And operator is opposit to or operator

var andRes = isWorking && isEnabled
console.log(andRes);

/**
 * if first operand(name) is truthy, then result is second operand  else
 * first operand
 */

message = name && "Sorry";
console.log(message);
todayMinPrice = price && 10;
console.log(todayMinPrice);
/////////////////////////////////////////////////////////////////////////////

//inverter !

var reached =true;
console.log(!reached)
var mycount =1000;
console.log(!mycount)

//dont invert !!
console.log(!!reached)
console.log(!!mycount)

///////////////////////////////////////////////////////////////////////////////////////

Conditional (ternary) operator
The conditional operator is the only JavaScript operator that takes three operands. The operator can have one of two values based on a condition. The syntax is:

condition ? val1 : val2

condition would be truthy or falsy

//tenary operators

var isEnabled = true;

var res = isEnabled ? "Enabled" : "Disabled";
console.log(res)

var name;
var found = name ? "Found" : "Not Found";
console.log(found)
/////////////////////////////////////////////////////////////////////////////////////////

Comparsional operators:
......................

1. less than <
2. less than or equal <=
3. greater than >
4. greater than or equal >=
5. ==, === equal
6. !=,!==

//relational operators

var x = 100;
var y = 10;
console.log((x < y) ? "less" : "not less")
console.log((x > y) ? "great" : "not great")
// == 

console.log((x == y) ? "equal" : "not equal")
console.log((x === y) ? "equal" : "not equal")

var a = "10";
var b = 10;
//test only value
console.log((a == b) ? "equal" : "not equal")
//test type + value : recommended operator ===
console.log((a === b) ? "equal" : "not equal")

console.log((a != b) ? "equal" : "not equal")
console.log((a !== b) ? "equal" : "not equal")
/////////////////////////////////////////////////////////////////////////////////////////////

Advanced operators

1.typeof - to know the type of variable
2.new  -  to allocate memory ; object creational operator
3.instance of - to know the parent type
4. in -  used with collection iterators
5. "." - object access operators
6. [] -  used to represent arrays elements &&  used to access object properties
7.{} -  to represent block of statements
8. of -  used with for loop
/////////////////////////////////////////////////////////////////////////////////////////////

Conditional statments and Control Structures:
..............................................

1.Decision making:

 if
 if..else
 if..elseif
 if ..elseif..else
 switch...case

statements:
  break;
 
//if and else

var a = 100;
var result='';
if (a > 0) {
    result = 'positive';
} else {
    result = 'NOT positive';
}
console.log(result)

..if..else if
var x = 10;

if (x > 50) {
    console.log("X is greater than 50")

} else if (x > 5) {
    /* do something */
    console.log("X is greater than 5")
} else {
    /* do something */
    console.log("No match found")
}
.........................................................................................



switch (expression) {

  case value1:
    //Statements executed when the
    //result of expression matches value1
    [break;]
  case value2:
    //Statements executed when the
    //result of expression matches value2
    [break;]
  ...
  case valueN:
    //Statements executed when the
    //result of expression matches valueN
    [break;]
  [default:
    //Statements executed when none of
    //the values match the value of the expression
    [break;]]
}

var expr = 'Papayas';
switch (expr) {
    case 'Oranges':
        console.log('Oranges are $0.59 a pound.');
        break;
    case 'Mangoes':
    case 'Papayas':
        console.log('Mangoes and papayas are $2.79 a pound.');
        // expected output: "Mangoes and papayas are $2.79 a pound."
        break;
    default:
        console.log(`Sorry, we are out of ${expr}.`);
}

//////////////////////////////////////////////////////////////////////////////////////////

Iterators -  loops;

1.for
2.while
3.do..while
4.for..in
5.for..of

var str = '';

for (var i = 0; i < 9; i++) {
    str = str + i;
}

console.log(str);

var n = 0;

while (n < 10) {
    console.log(n)
    n++;
}

console.log(n);
// expected output

var result = '';
var i = 0;

do {
    i = i + 1;
    result = result + i;
} while (i < 5);

console.log(result);
// expected result: "12345"

/////////////////////////////////////////////////////////////////////////////////////////////

Functions:
..........

What is function?

 function is block, inside we can define the logic.

syntax :

function declaration

 function functionName(args) {

   //block of code
 }

function invocation.


//define basic functions

function sayHello() {
    //block of code
    console.log('hello javascript')
}
//function invocation.
sayHello();

////////////////////////////////////////////////////////////////////////
The function with logic:
function add() {
    var a = 10;
    var b = 20;
    var c = a + b;
    console.log(`The addition ${c}`)
}
add()
/////////////////////////////////////////////////////////////////////////////////////////////
//parameters and args:
.....................

-javascript is type less , so args can take any type of literal

//function args and parameters
//message is arg
function sayHello(message) {
    console.log(message);
}
//pass value is here parameter
sayHello('Hello');
sayHello(10)
sayHello(true)
sayHello()
sayHello(NaN)


function add(a, b) {
    var result = a + b;
    console.log(result)
}
add(10, 10);
add()
add("10", "20")
add("10", 10)
add(10)
add(8, 8, 10)

function multiply(a, b) {
    //default value initalization if variables having undefined 
    //this is es 5 style
    a = a || 0;
    b = b || 0;
    var res = a * b;
    console.log(res);
}
multiply(10, 10)
multiply()
//es 6 style of default value initalizaiton
//default args
function multiplyE6(a = 0, b = 0) {
    var res = a * b;
    console.log(res);
}
multiplyE6(18, 10)
multiplyE6()
/////////////////////////////////////////////////////////////////////////////
//what if i want to pass more parameters, i dont know in advance how many args 
//i pass
function logger() {
    //arguments : built in variable, holding all parameter values
    console.log(arguments) //es 5 syntax
}
logger('hello')
logger('hello', 'greet')
logger('hello', 'welldone', 'good', 'js')

//Rest Operator : ... es 6 syntax to replace "arguments"
function sum(...numbers) {
   console.log(numbers)
}
sum(1, 2, 4);
sum(1, 2, 3, 4, 5, 6, 7, 8)

//////////////////////////////////////////////////////////////////////////////////////////////

What(literal) can be passed as parameter?

All literals can be passed as parameter.
 -strings,numbers,boolean,undefined,function,null,object,nan,infinity.


functions types:

1.user defined functions
  eg ; sayHello,add,compute
2.global built in functions
   functions are defined by js language.
 parseInt,parseFloat,isNaN,eval,isFinite,encodeURI(),decodeURI...


function compute(res) {
    if (isNaN(res)) {
        console.log('SOrry computation is failed')
    } else {
        console.log(res);
    }
}
var x = 10;
var y = 20
compute(x * y)
x = "$10"
compute(x * y)

function findAvg(a, b) {
    var res = a / b;
    if (res === Infinity) {
        console.log('div by 0 ')
    } else {
        console.log(res);
    }
}
findAvg(10, 2)
findAvg(10, 0)
////////////////////////////////////////////////////////////////////////////////////////////

How to return values from the function?

function can return any literal
///function returns

///function returns

function sayHello() {
    return 'Hello';
}
console.log(sayHello())

function sayHai() {
    var message = 'hai'
    return message;
}
console.log(sayHai())

function sayGreet() {
    return;
}
console.log(sayGreet())

function add(a = 1, b = 1) {
    return a + b; //expression
}
console.log(add(1, 2))

function validate(username = 'root', password = 'root') {
    if (username === 'admin' && password === 'admin') {
        return true;
    }
    return;
}
validate() ? console.log('success') : console.log('failed')
validate('admin','admin') ? console.log('success') : console.log('failed')

////////////////////////////////////////////////////////////////////////////////////////////

How to implement recurssive functions?
fact

function factorial(n) {
    if ((n === 0) || (n === 1))
        return 1;
    else
        return (n * factorial(n - 1));
}
console.log(factorial(5))


//////////////////////////////////////////////////////////////////////////////////////////

functional Programming:
.......................

functional programming is one of the programming style/paradigm. introduced in 1950's.


Lambda calculus:

 Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution.
 It was introduced by the mathematician Alonzo Church in the 1930s as part of his research into the foundations of mathematics.

Lambda calculs Implementation:

The Programming languages which implements "lambda Calculus theory" called "Functional programming".


Lambda expressions the programs construction through "functions" -->f()

The languages which implements lambda Calculus
 ->LISP
 ->Scheme
 ->haskell

etc........

style vs pure:
..............
  if a pl implements 100% principles of an functional paradigm-lambda calculs, 
  those languages called "Pure"

  if a pl implements not all principles or partially,   those languages called "style".


Functional Programming Principles:

what is function? - 
  according lambda calculs , function is representation of computation. which receivies input,process it, return it.- unit of operation

-Functions are "first-class citizen” : function abstraction.
-Functions can be assigned to variables
-Composition of functions 
-Higher order functions
-Functions can be passed as parameters
-Functions can be returned as a result
-Functions without side effects (referential transparency) ; pure functions
-Persistent (immutable) data structures
-Algebraic data types (sum and product types)
-Pure functional programming has no loops(for..while), they support only recurrsion


Does javascript is pure functional programming language?

No!.
javascript is "functional style" programming language.

According to functional programming,
  "functions" are values(literals).

Since function is value(literal) like strings and numbers, can be assigned to a variable
 eg:
  var a=10;
  var name="subramanian"
  var f = function(){} - valid

Since function is value(literal) like strings and numbers, can be passed around function.
...........................................................................................

Since function is value(literal) like strings and numbers, can be assigned to a variable.
That variable can be used to invoke that function.


How to declare functions?

//how to declare functions and how to call it.

//way -1 
function sayHello(name) {
    console.log('hello', name);
}
sayHello('subramanian');

//function is literal. you can assign to a variable.
var hello = sayHello;
console.log(hello);
hello('ram');
/////////////////////////////////////////////////////////////////////////////
//inline function declaration.
//way -2
var hai = function sayHai(name) {
    console.log('hi', name);
};
hai('subu')
//sayHai()

//way -3 : anonymous function ; function without name
var greet = function (name) {
    console.log('greet', name);
};
greet('subu')
//////////////////////////////////////////////////////////////////////////////////////////////

Function as Parameter:
....................

functions can be passed as parameter to another function.

//function as parameter to another function.

function add(a, b) {
    var c = a + b;
    console.log(c);
}
//passing parameters
//via variables
var x = 10;
var y = 10;
add(x, y);
//hardcoded values
add(10, 20)
//////////////////////////////////////////////////////////////////////////////////
//hai = greet = 
function sayGreet(callback) {
    var status = callback('subramanian');
    console.log(status);
}
//regular function
function sayHello(name) {
    console.log('hello', name)
    return 'done'
}
//via variable
var greet = function (name) {
    console.log('Hai', name)
    return 'done'
};
sayGreet(greet)

//hardcode values
sayGreet(function (name) {
    console.log('hai hai')
    return 'done'
});
sayGreet(sayHello)
/////////////////////////////////////////////////////////////////////////////////////////////

How to declare reciver function in literal pattern?


var sayGreet = function (callback) {
    var status = callback('subramanian');
    console.log(status);
}
//hardcode values
sayGreet(function (name) {
    console.log('hai hai')
    return 'done'
});

///////////////////////////////////////////////////////////////////////////////////////////

How to pass more than one parameter as function?


// function login(userName, password, success, failure) {
//     if (userName === 'admin' && password === 'admin') {
//         //send success result via function to the caller
//         success(`Login success : ${userName}`)
//     } else {
//         failure('Login failed');
//     }
// }
var login = function (userName, password, success, failure) {
    if (userName === 'admin' && password === 'admin') {
        //send success result via function to the caller
        success(`Login success : ${userName}`)
    } else {
        failure('Login failed');
    }
};

login('admin', 'admin', function (message) {
    console.log(message)
}, function (err) {
    console.log(err)
});


login('foo', 'admin', function (message) {
    console.log(message)
}, function (err) {
    console.log(err)
});
/////////////////////////////////////////////////////////////////////////////////////////////

Best practice: test whether you have passed function?

function doStuff(callback) {
    if (typeof callback === 'function') {
        callback();
    } else {
        console.log('Wrong type ')
    }

}
doStuff(function () {
    console.log('done')
})
doStuff('foo')
//////////////////////////////////////////////////////////////////////////////////////////////

How to return function from another function?

inner functions:
 function is declared with in another function


Note:

any declaration inside function (exect instance members), not visible outside that function
-local scope.



function outter() {
    var myvar='foo'
    console.log('outter')
    function inner() {
        console.log('inner')
    }
}
outter();
 inner();
//console.log(myvar)

if you run the above code , you will get error message
inner();
^

ReferenceError: inner is not defined
    at Object.<anonymous> (C:\session\astro\2021\js-apps\src\index.js:20:1)
    at Module._compile (internal/modules/cjs/loader.js:959:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)
    at Module.load (internal/modules/cjs/loader.js:815:32)
    at Function.Module._load (internal/modules/cjs/loader.js:727:14)
    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)
    at internal/main/run_main_module.js:17:11


The function is not visible outside, similary the myvar variable.


How to call/invoke the innerfunction?

Two soultions:

1.within in outter function

function outter() {
    var myvar='foo'
    console.log('outter')
    function inner() {
        console.log('inner')
    }
    //calling inside outter function
    inner();
}
outter();

2.return the that function outside and call it

way-1
function outter1() {
    var myvar = 'foo'
    console.log('outter')
    function inner() {
        console.log('inner')
    }
    return inner;
}
var res = outter1();
console.log(res);
res();

way-2

function outter1() {
    var myvar = 'foo'
    console.log('outter')
    return function inner() {
        console.log('inner')
    }
}
var res = outter1();
console.log(res);
res();

way-3 - return anonymous function
function outter1() {
    var myvar = 'foo'
    console.log('outter')
    return function () {
        console.log('inner')
    }
}
var res = outter1();
console.log(res);
res();


way-4; calling function refactoring

function outter1() {
    var myvar = 'foo'
    console.log('outter')
    return function () {
        console.log('inner')
    }
}
// var res = outter1();
// console.log(res);
// res();
//refactoring calling syntax
outter1()();


can we pass any parameters to the inner function from outside?

function outter1() {
    var myvar = 'foo'
    console.log('outter')
    return function (name) {
        console.log('inner',name)
    }
}
var res = outter1();
res('subramanian');
//refactoring calling syntax
outter1()('subramanian');

can inner function return value to outside?

function outter1() {
    var myvar = 'foo'
    console.log('outter')
    return function (name) {
        return `inner ${name}`;
    }
}
var res = outter1();
console.log(res('subramanian'));
//refactoring calling syntax
console.log(outter1()('subramanian'));


can outter function be an variable pattern?

var outter1 = function () {
    console.log('outter')
    return function (name) {
        return `inner ${name}`;
    }
};
var res = outter1();
console.log(res('subramanian'));
//refactoring calling syntax
console.log(outter1()('subramanian'));
//////////////////////////////////////////////////////////////////////////////////////////////

functions related concepts:
..........................

1.async programming
2.closure
3.curry functions /higher order function.
4.recurssive functions
5.anonmous functions
6.IIFE functions- immediately invoked function expression.
7.ES 6 Functions -arrow function.

IIFE:
 IT is self executing anonmouys function.
 The function executes itself.
 It is very usefull for initalization applications.

//IIFE function., no name.


(function () {
    console.log('app is initalied')
})();
// iife with params

(function (name = 'default') {
    console.log(name);

})('foo');

//iife with return value

var result = (function (name = 'default') {
    return name;
})('foo');
console.log(result);
///////////////////////////////////////////////////////////////////////////////////////

Arrow functions:

An arrow function expression is a compact alternative to a traditional function expression,
but is limited and cant be used in all situations.

Arrow differences and limitations:
..................................

1.does not have its own bindings to "this or super".
2.It should not be used as methods in objects.
3.It does not have arguments keywords
4.cant be used as constructors
5.cant use "yield" keyword within its body.

Basic arrow 


//es 5 function expression syntax
var hai = function () {
    console.log('hai');
};
hai();
//arrow will replace the above one.

var hello = () => {
    //function body
    console.log('hello');
};
hello();

//if function body has one line of code, we can remove {}
hello = () => console.log('hello');
hello();

///arrow and parameters ; more parameter with default value.

var add = (a = 0, b = 0) => {
    var result = a + b;
    console.log('add', result);

};
add(10, 10);
///arrow and parameters ; single parameter with out default value,you can remove()
var getStock = value => console.log(`Stock Value ${value}`)
getStock(100)
//////////////////////////////////////////////////////////////
//arrow functions and return
var getName = () => {
    return 'Subramanian';
};
console.log(getName())
//if function has only return statement, you can remove {} and return statement
getName = () => 'Subramanian';
console.log(getName())

/////////////////
//if function recieves single input,without default value and return the same
var myfunc = input => input;
console.log(myfunc('hello'))

/////////////////////////////////////////////////////////////////////////////////////////

Arrow functions and function as parameter and IIFE Functions
//function as parameter

// function sayGreet(callback) {
//     callback();
// }

var sayGreet = callback => {
    callback('subramanian');
}
var hello = name => console.log('hello', name)
sayGreet(hello);
sayGreet(name => console.log('hello arrow'));

/////////////////////////////////////////////////////////////////////////////

// function outter() {
//     console.log('outer')
//     return function inner() {
//         console.log('inner')
//     }
// }
// function outter() {
//     console.log('outer')
//  return () => {
//         console.log('inner')
//     }   
// }
// function outter() {
//     console.log('outer')
//     return () => console.log('inner')

// }
// var outter = () => {
//     console.log('outer')
//     return () => console.log('inner')
// }
var outter = () => () => console.log('inner')
outter()();

(() => console.log('app is initalied'))();

((name = 'default') => console.log(name))('foo');
var result = ((name = 'default') => name)('foo');
console.log(result);
/////////////////////////////////////////////////////////////////////////////////////////////

Object based(oriented) Programming:
...................................

What is oo programming?

 OO is another paradigm/style of writing application.

What is Object?

 Views of Object :

1.Domain - Problem
    Object could be anything, but that should be relavant to the problem domain - graddy booch.

eg:
 if you are building health care app, marks are not relavent to the domain. according to
health care students marks are not object.

Object Oriented Principles:
...........................

1.Abstraction
2.Encapsulation
3.Hierarchy
4.Typing
5.Modularity
----------------------
6.Concurrency
7.Persistency

    
2.implementation

-What is object?
 Object is memory represenation.
 Object is collection of properties
 Property could be variables having primitive values, methods(functions)
 Property could be another object

Pure Object oriented Programming languages(c++,java,C#) class based languages.

class is fundmental representation  of object properties in source code.
Without class no object created.
////////////////////////////////////////////////////////////////////////////////////////////

Stages of Object creation:
..........................

0. source code
  we classes to represent object properties
 eg:
  Customer.java
   class Customer{
       int id;
       String name;
       public double calculateTax(){
           return 100.89;
       }
   }
1.compile time
  Customer.class

  class Customer{
       int id;
       String name;
       public double calculateTax(){
           return 100.89;
       }
     
   }
  +
  extra code
     memory allocation information table- Virtual table-array of information.

  
2.runtime time

  Customer.class--loaded into runtime----Run time will start allocating memory
  --Object(Runtime representation of class)


Once object is created we can do three things

1. we set values on object properties
2. we get values on object properties
3. We can execute methods on object
..............................................................................................

Static and dynamic language:
............................  

static languages fixes object layout during compile time itself, using virtual table.
during runtime we cant alter the object layout.

dynamic languages dont have compile time object layout, does not use "Virtual table"
rather who uses datastructures -  dictionary(key-value) , during runtime we can alter object


Js and Objects:

1.js does not use classes for creating object.uses functions
2.js objects are dynamic
3.js objects are allocated inside heap memory of js engine.
4.IN js everthing object almost.
    -Js code itself object - context - Execution Context.
5.objects can be created in many ways

   1.using functions
   2.using literals
   3.using Object.create method
   4.using es 6 class

Object Properties:

 1.variables - instance variables
 2.methods - instance methods
 3.constructors - function to initalize the variables.

how to declare object properties?

 this keyword  - inside function
 super keyword
 without any keyword.


Note: 

 functions are first class citizens 
   -used to encapsulate logic -
   -used to encapslate object properties

how we can change function rolls
   function myfun(){}

   myfun()---regular execution
  new myfun() - constructor execution- object creation.

Recommendations:

 1.in case if function is used for logic , naming convention could be
    verb+Noun -  doStuff() / verb - calculate().
 2.in case if function is used for object , naming convention could be
    Noun-  Employee,Customer


..........................................................................................

How to create object?
//

function Employee() {
    //object properties
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;

}
//emp is reference variable,points the object location.
var emp = new Employee();
console.log(emp)

how to access/get object properties?

we have operator

 "." operator
 "[]" operator

//

function Employee() {
    //object properties
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;

}
//emp is reference variable,points the object location.
var emp = new Employee();
console.log(emp)
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary}`)
console.log(`Id ${emp['id']} name ${emp['name']} Salary ${emp['salary']}`)

how to define methods?
//

function Employee() {
    //object properties
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;
    //methods : via function
    this.calculateLeave = function (leave = 1) {
        return leave;
    }


}
//emp is reference variable,points the object location.
var emp = new Employee();
console.log(emp)
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
console.log(`Id ${emp['id']} name ${emp['name']} Salary ${emp['salary']}`)

/////////////////////////////////////////////////////////////////////////////////////////////

How many objects you can create out of single function?

many objects, subject to memory .

Each object has its own memory location.

//

function Employee() {
    //object properties
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;
    //methods : via function
    this.calculateLeave = function (leave = 1) {
        return leave;
    }


}
//emp is reference variable,points the object location.
var emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
var emp1 = new Employee()
console.log(`Id ${emp1.id} name ${emp1.name} Salary ${emp1.salary} leave ${emp1.calculateLeave(12)}`)

///////////////////////////////////////////////////////////////////////////////////////////

How to reuse one reference to create multiple objects and how to use them?.

Null:
Null is object, having no properties.
used to identicate that the reference variable is going to hold objects in futures
used to report meaningfull errors

//

function Employee() {
    //object properties
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;
    //methods : via function
    this.calculateLeave = function (leave = 1) {
        return leave;
    }


}
var emp = null;
console.log(typeof emp);
emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
/////////////////////////////////////////////////////////////////////////////////////////////

State initalization:(instance variable)
.......................................

1.hardcoded inside function
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;

2.after object creation
var emp = null;
console.log(typeof emp);
emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
//state initalization
emp.id = 9000;
emp.name = 'Ram';
emp.salary = 88888;
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)


3.during object creation; consturctor parameters

//

function Employee(id = 1, name = 'Subramanian', salary = 10000) {
    //object properties
    this.id = id // 1;
    this.name = name //'Subramanian';
    this.salary = salary //10000;
    //methods : via function
    this.calculateLeave = function (leave = 1) {
        return leave;
    }


}
var emp = null;
emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
emp = new Employee(888, 'foo', 87666) //constructor parameters
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
emp = new Employee(888, 'foo', 87666) //constructor parameters
emp.id = 1200
emp.name = 'bar';
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)

/////////////////////////////////////////////////////////////////////////////////////////

Can Object return instance variables via instance methods?

Yes
//

function Employee(id = 0, name = '', salary = 0) {
    //object properties
    this.id = id // 1;
    this.name = name //'Subramanian';
    this.salary = salary //10000;
    this.bonus = 2.5;
    //methods : via function
    this.calculateBonus = function () {
        return this.salary * 2.5 / 100
    }
    this.calculateAnnualSalary = function () {
        return this.calculateBonus() + this.salary;
    }
}
var emp = null;
emp = new Employee(1, 'Subramanian', 49500)
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} Bonus ${emp.calculateBonus()} Annual salary ${emp.calculateAnnualSalary()}`)

///////////////////////////////////////////////////////////////////////////////////////////
Encasulation:

js is very weak by providing  code sharing feature.

if you declare any thing inside function, you cant access outside with help of var declartion /regular function declaration.
 if you do so inside object template, then those things are called private variables/methods


//

function Employee(id = 0, name = '', salary = 0) {
    //object properties
    this.id = id // 1;
    this.name = name //'Subramanian';
    this.salary = salary //10000;
    //private variable
    var bonus = 2.5;
    //methods : via function
    this.calculateBonus = function () {
        return computeBonus();
    }
    this.calculateAnnualSalary = function () {
        return this.calculateBonus() + this.salary;
    }
    var tempSalary = this.salary;
    //private function
    // function computeBonus() {
    //     console.log(this.salary);
    //     return this.salary * bonus / 100
    // }
    function computeBonus() {
        return tempSalary * bonus / 100
    }
}
var emp = null;
emp = new Employee(1, 'Subramanian', 49500)
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} Bonus ${emp.calculateBonus()} Annual salary ${emp.calculateAnnualSalary()}`)
///////////////////////////////&&&&&&&&&&&&&&&&&&&&&&&&&&////////////////////////////////////

Hierachy:
 Object relationship. In applications objects collabrate each other.How objects can share their code(data,methods).

Types of Hierachy:
1.HAS-A - Composition/association
2.IS-A  -  Inheritance.

//has a 

function Phone(mobileno = "1234567890") {
    this.mobileno = mobileno
}

function Address(doorno = "doorno", street = "street", city = "city", state = "state", zip = "zip", mobileno = new Phone()) {
    this.doorno = doorno;
    this.street = street;
    this.city = city;
    this.state = state;
    this.zip = zip;
    this.mobileno = mobileno;
}

function Employee(id = 0, name = "defaultName", salary = 0.0, address = new Address()) {
    this.id = id;
    this.name = name;
    this.salary = salary;
    //address - doorno,street,city,state,zipcode-has-a 
    this.address = address;
}
//how to associate objects

var emp = null;

emp = new Employee();
console.log(emp);

var phone = new Phone("9003407867")
var address = new Address("10/5", "gandhi street", "Coimbatore", "Tamil Nadu", "600 001", phone)
emp = new Employee(1, "Subramanian", 1000, address);
console.log(emp);

emp = new Employee(1, "Subramanian", 1000, new Address("10/5", "gandhi street", "Coimbatore", "Tamil Nadu", "600 001", new Phone("9003407867")))

/////////////////////////////////////////////////////////////////////////////////////
  
IS-A: Inheritance:
.................

What is inheritance?

  It is type of relationship between objects.
  It is relatiship type.

Why inhiertance?
  ->To achive high degree of code resuablity.
    ->code- variables,functions -Object(variables+methods) : classes,interfaces(java)
  ->Keep code in one object and share across mutliple objects without redefining it

Java script inheritance is completly different from "c++/java" based languages.

"C++/java" inheritance is called "classical inheritance" , where javascript inheritance
is called "Prototypical inheritance".

classical vs prototypical:
.........................

1.classical inheritance is "class" based inheritance.
   inheritance is decided during compile time.

eg: java
source code

A.java
class A{
  //object properties
  void doStuff(){
  }
}
B.java
class B extends A {

}

compiled code:
A.class
class A{
  //object properties
  void doStuff(){
  }
}
B.class
class B extends A {
 //object properties
  void doStuff(){
  }
}

2.prototypical inheritance is "object" based inheritance.

Code sharing happens during runtime only.

Object A (code) ------ Object B  -> try to access Object A property from b.

Javascript and "prototypical  inheritance":
...........................................

Prototype:

  Every object, when is created, receives its prototype. If the prototype is not set explicitly, objects receive default prototype as their inheritance object.


The prototype objects are used to implement inheritance with the mechanism of 
"dynamic dispatch-property lookup"

A prototype is a "delegation object" used to implement prototype-based inheritance.

Delegation/Proxy Design pattern:
...............................

Use case 1
The job is not done by the Program(Object) itself rather dispatch/delegates to other objects
 eg: async arch.

Use case 2
In js Prototype is delegation object used for shared properties.(Inheritance).
 This type of inheritance is called as "Prototypical  inheritance"
////////////////////////////////////////////////////////////////////////////////////////////

How to verify the Default Prototype Object?


function Employee(id = 0, name = "foo") {
    this.id = id;
    this.name = name;
}
var emp = new Employee();
console.log(emp);

Test this code in browser.

Employee
id: 0
name: "foo"
__proto__:
constructor: ƒ Employee(id = 0, name = "foo")
__proto__:
constructor: ƒ Object()
hasOwnProperty: ƒ hasOwnProperty()
isPrototypeOf: ƒ isPrototypeOf()
propertyIsEnumerable: ƒ propertyIsEnumerable()
toLocaleString: ƒ toLocaleString()
toString: ƒ toString()
valueOf: ƒ valueOf()
__defineGetter__: ƒ __defineGetter__()
__defineSetter__: ƒ __defineSetter__()
__lookupGetter__: ƒ __lookupGetter__()
__lookupSetter__: ƒ __lookupSetter__()
get __proto__: ƒ __proto__()
set __proto__: ƒ __proto__()


Prototype chain: 
................
    A prototype chain is a finite chain of objects used to implement inheritance and shared properties.

  Employee ----->Prototype-----Object----->null


How to share code in Prototype and how to share it across multiple objects.


function Employee(id = 0, name = "foo") {
    this.id = id;
    this.name = name;
}
var emp = new Employee();

//
console.log(`Id ${emp.id}`);
console.log(`Name ${emp.name}`);
//?
console.log(`Salary ${emp.salary}`);

when you run the above code , you will get output like below.

Id 0
Name foo
Salary undefined

how salary got undefined?

Delegation: a mechanism used to resolve a property in the inheritance chain. The process happens at runtime, hence is also called dynamic dispatch

"The rule is very simple:
   "if a property is not found in the object itself, there is an attempt to resolve it in the prototype; in the prototype of the prototype, etc. — until the whole prototype chain is considered."

how to add propery in the current object?

inside object template

function Employee(id = 0, name = "foo") {
    this.id = id;
    this.name = name;
}
but js is dynamic language : you can add,update,delete,iterate properties during runtime, even
after object is created : "Object Augmentation".
//?
//object augmentation: add property
emp.salary = 10000;

//object augmentation: update property
emp.name ="subramanian"

add vs update:
...............

 if property exits in the chain, update happens, if not then add will happen.


How to delete property? using delete operator.

delete emp.department;
*******************************************************************************************

Shared Properties:
...................

 Properties can be shared across multiple "instances"

instance keeps its own data.

lets assume if i create 10 instance out of "Employee" , each instance data will be different.



function Employee(id=0,name="foo"){
    this.id=id;
    this.name = name;
}
//create two instances

var emp1 = new Employee();
emp1.id =1000;
emp1.name="Subramanian"
console.log("employee 1 data")
console.log(`Id ${emp1.id}`);
console.log(`Name ${emp1.name}`);

var emp2 = new Employee();
emp2.id =22222;
emp2.name="Ram"
console.log("employee 2 data")
console.log(`Id ${emp2.id}`);
console.log(`Name ${emp2.name}`);


i want to have common data(Shared Properties) for both instances
................................................................

You have to add properties inside "Prototype" Object.

How to get Prototype Object?

Function.prototype


function Employee(id = 0, name = "foo") {
    this.id = id;
    this.name = name;
    this.bouns = 999;
}

//get Prototype of employee
console.log(Employee.prototype)

//augment Prototype Object
Employee.prototype.salary = 900.00;
Employee.prototype.calculateBonus = function () {
    return this.bouns;
}
Employee.prototype.calculateSalary = function () {
    return this.salary * 100;
}
//create two instances
var emp1 = new Employee();
emp1.id = 1000;
emp1.name = "Subramanian"
console.log("employee 1 data")
console.log(`Id ${emp1.id}`);
console.log(`Name ${emp1.name}`);
console.log(`Salary ${emp1.salary}`);
console.log(`Bouns ${emp1.calculateBonus()}`);
console.log(`totalsalary ${emp1.calculateSalary()}`);



var emp2 = new Employee();
emp2.id = 22222;
emp2.name = "Ram"
console.log("employee 2 data")
console.log(`Id ${emp2.id}`);
console.log(`Name ${emp2.name}`);
console.log(`Salary ${emp2.salary}`);
console.log(`Bouns ${emp2.calculateBonus()}`);
console.log(`totalsalary ${emp2.calculateSalary()}`);

Lookup chain:
Prop--->parent 1--->parent 2--->parent 3--->parent n-- | null

object.__proto__:Object
           |
           object.__proto__:Object
  	   |
	           object.__proto__:null

If property not found any object in the chain, it will return undefined.
 obj.x--->not p-->not p-->Object-->undefined
/////////////////////////////////////////////////////////////////////////////////////////

Explicit inheritance:

 what if i dont want my parent object would be "Prototype".

eg:
  Create Class SavingsAccount---inherit---ACCOUNT---Prototype----Object

If you want link two objects 
  ->__proto__ you can use but it is not ECMA Standard
  ->Object.create is utilty api used to link two objects -ECMA     Standard


..................................................................................

How to link two objects:

Child.prototype  = Object.create(Parent.prototype)
//linking objects: inheritance;

//base class 
function Person(name = 'default') {
    console.log('Person is called')
    this.name = name;
}
Person.prototype.sayGreet = function () {
    return 'greet'
}
//child class
function Employee(name) {
    //calling super class constructor.
    Person.call(this,name); //binding base class and child class
    console.log('Employee is called')
}
//Linking Objects : establishing inheritance:
Employee.prototype = Object.create(Person.prototype);

var emp = new Employee("Subramanian");
console.log(emp.name);
console.log(emp.sayGreet())


var emp1 = new Employee();
console.log(emp1.name);
console.log(emp1.sayGreet())
//////////////////////////////////////////////////////////////////////////////////////////////

Object creation using literal Pattern:
......................................

1.no function is used to create object
2.object can have properties and methods
3.literal objects dont have prototypes.
4.literal objects can be inherited, default base object is "object".
5.litreal objects can be nested- has-a.
6.literal objects do have constructors.

syntax:

var refVariable = {
 prop1:literal,
 prop2:literal,
 etc....
};



var emp = {
    id: 1,
    name: 'subramanian',
    salary: 1000,
    calculateSalary: function () {
        return this.salary * 10;
    }
};
console.log("Literal Object details")
console.log(`id ${emp.id}`)
console.log(`name ${emp.name}`)
console.log(`Salary ${emp.salary}`)
console.log(`Total Salary ${emp.calculateSalary()}`)


//state initalization; no constructors

var emp = {
    id: 1,
    name: 'subramanian',
    salary: 1000,
    calculateSalary: function () {
        return this.salary * 10;
    }
};

emp.name = 'karthik'
emp.salary = 9000;
console.log("Literal Object details")
console.log(`id ${emp.id}`)
console.log(`name ${emp.name}`)
console.log(`Salary ${emp.salary}`)
console.log(`Total Salary ${emp.calculateSalary()}`)
/////////////////////////////////////////////////////////////////////////////////////////////
How to implement hierachy?

//has-a ; nested object

var emp = {
    id: 1,
    name: 'subramanian',
    salary: 1000,
    address: {
        street: '10th',
        city: 'coimbatore',
        phone: {
            mobileno: '900897878'
        }
    },
    calculateSalary: function () {
        return this.salary * 10;
    }
};

console.log("Literal Object details")
console.log(`id ${emp.id}`)
console.log(`name ${emp.name}`)
console.log(`Salary ${emp.salary}`)
console.log(`Address ${emp.address.city} ${emp.address.phone.mobileno}`)
console.log(`Total Salary ${emp.calculateSalary()}`)

/////////////////////////////////////////////////////////////////////////////////////////////

How to implement is-a relationship in literal object?

-parent object
  unlike functions, literals has no prototype object.
  Immediate parent object is "Object".



var parent = {
    color: 'red'
}
var child = {
    size: 10
}
child.__proto__ = parent;
console.log(child.size, child.color);

var product = {
    color: 'pink'
}
var item = Object.create(product);
item.size = 100;
item.price = 98;
item.qty = 90;
console.log(item.color,item.size,item.price,item.qty)
///////////////////////////////////////////////////////////////////////////////////////////////
                                   ES 6 Classes
/////////////////////////////////////////////////////////////////////////////////////////////

1.ES 6 classes are alternate syntax for function based objects.
2.ES 6 classes are simple to use, abstracts many complixites
3.It is easy to understand , debug,clear code for oo developers
4.All es 6 classes are functions only internally.
5. which has keywords class,"constructor",extends,this,super.
6. inside class we can declare instance variables, methods without this keyword.
7.object creation syntax remains same.


//es 6 classes

class Employee {
    //instance variables
    id = 0;
    name = 'foo';
    //methods
    calculateSalary() {
        return 100
    }
}
//create object
var emp = new Employee();
console.log(emp.id,emp.name,emp.calculateSalary())

state initalization:
//es 6 classes

class Employee {
    //instance variables
    // id = 0;
    // name = 'foo';
    constructor(id = 0, name = 'foo') {
        this.id = id
        this.name = name;
    }
    //methods
    calculateSalary() {
        return 100
    }
}
//create object
var emp = null;
emp = new Employee();
emp.id = 1;
emp.name = 'bar'
console.log(emp.id, emp.name, emp.calculateSalary())

emp = new Employee(2, 'subramanian');
console.log(emp.id, emp.name, emp.calculateSalary())

Arrow functions inside classes:
//es 6 classes

class Employee {
    //instance variables
    // id = 0;
    // name = 'foo';
    constructor(id = 0, name = 'foo') {
        this.id = id
        this.name = name;
    }
    //methods
    calculateSalary() {
        return 100
    }
    calculateLeave = () => 10;
}
//create object
var emp = null;
emp = new Employee();
emp.id = 1;
emp.name = 'bar'
console.log(emp.id, emp.name, emp.calculateSalary(),emp.calculateLeave())

emp = new Employee(2, 'subramanian');
console.log(emp.id, emp.name, emp.calculateSalary(),emp.calculateLeave())

//////////////////////////////////////////////////////////////////////////////////////////

Hierachy inside classes:
........................

//has-a

class Product {
    constructor(pid = '00', pname = 'foo') {
        this.pid = pid;
        this.pname = pname
    }
}
class Order {
    constructor(orderId = 'A000', product = new Product()) {
        this.orderId = orderId;
        //has-a
        this.product = product;
    }
}
var order = null;
order = new Order();
console.log(order.orderId, order.product.pname)

order = new Order(1, new Product(90, 'myproduct'));
console.log(order.orderId, order.product.pname)
/////////////////////////////////////////////////////////////////////////////////////////////

Inheritance:
............


//shared property
class Product {
    constructor(id) {
        this.id = id;
    }
}
Product.prototype.price = 100;
Product.prototype.qty = 10;

class Computer extends Product {
    constructor(id = 0, name) {
        super(id)
        this.name = name;
    }
}


// var product = null;
// product = new Product(23);
// console.log(product.id, product.price, product.qty)

// product = new Product(34);
// console.log(product.id, product.price, product.qty)


var product = null;
product = new Computer(23);
console.log(product.id, product.price, product.qty)

product = new Computer(34);
console.log(product.id, product.price, product.qty)
















































