
Lab:
Javascript Runtime:

Browser:
 has embeded javascript runtime/engine/vm

Standalone:
 Node.js 

IDE
 Microsoft vs code

///////////////////////////////

Project setup:
.............


1.select workspace

c:\session\astro\2021\

2.create project folder

c:\session\astro\2021\ js-apps\src

3.lanuch project

c:\session\astro\2021\ js-apps\src\ code .

..........................................................................................
                                        Javascript


What is Javascript?

 The javascript is programming language.

Style of javascript

 standalone styles - inital java - before java 8 -  object oriented programming language
 hybrid styles - mixing many styles in one place.java 8  hybrid style language

javascript was designed as hybrid programming language.
 
javascript supports "functional style","Object based","Event driven" .

History of javascript programming:
..................................

1989 - Web Project was started    -------Sun created Java

1990 -  The first webserver,Browser was created

1994 - Netscap started

1995 - The first netscap navigator came to access web pages 

1996 - Netscap decided to put java inside webbrowser.

----Static web----- only hand coded html pages.

1996 - CREATED Dynamic web : how to work with databases
     - CGI - C,perl.
 J2EE- Servlets,JSP
 MS  - ASP
 OPEN SOURCE - PHP.

 Server side web : create html pages on fly by including data from databases.

Netscap decided to build client side web technoloy- once html is rendered into web browser
how to change that html onfly. 

Netscap decided to create a new programming language, who recurited Brendan Eich
,the programmer , asked to create new programming language for netscap navigator.

-Objective of Project

-It should be like java but it should not be java -light weight - scripting
-deadline is 10 days.

Time line:

1.javascript project started 1995

1.first name of the language was "Mocha"
2.language was renamed to "Live Script" -1996
3.language was renamed to "java Script" -1996



After language ready, which was submitted to standard body "ECMA international"

1996---1997 : JS 1.0 =>ES 1.0

1997- 1998 :  ES 2.0: It did not come

1999 :  ES 3

2007 : ES 4

2008 : ES 5

2012-2015 : ES 6

2016  ONWARDS : es 7,es 8, ......

//////////////////////////////////////////////////////////////////////////////////////////


...........................................................................................

Compilation,Execution, Runtime:
...............................

Javascript has no independant compiler like c++/java.

Runtime: 

 It is program, written in c / c++ , any language.
 Runtime is abstraction/communication layer between os and application programms.

Types of runtime:

1.embeded runtime
  embeded into another software
 eg:
   embeded game engines...
   browsers has lot of embbeded 

   webservers which running java code : tomcat

2.standalone runtime
  which is avaiable separatly
  JVM


Javascript runtime:
...................
 it is avaiable in both mode.

Embeded mode:
  js runtime is avaiable inside every browser.

chrome : V8 
firefox : Spider Monkey
ms : chakra .

standalone mode:
  node js, which has standalone js runtime.
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

Does javascript code is compiled?

 Yes! , inside javascript runtime, which has embbeded compiler.
////////////////////////////////////////////////////////////////////////////////////////////

We are going to use v8:
  "V8 is Google’s open source high-performance JavaScript and WebAssembly engine, written in C++. 
It is used in Chrome and in Node.js, 
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
Where is javascript ? what type of applications we can build using javascript?

1.javascript was created for browser only to process web documents.

Now a days  javascript is used every where.

1. javascript is in server side market : for build Webapps,webservices :Node.js
2. javascript is in mobility  : build mobile applications
3. javascript is in IOT : build any device specific applications.
/////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////

Java Script Programming language: ES 5 AND ES 6
...............................................

1.language fundamentals
2.functional programming
3.Object based programming
4.Browser specific features
   DOM,AJAX.

Node Js:
   Build Nonblocking IO applications 

/////////////////////////////////////////////////////////////////////////////////////////

language fundamentals:

1.type system
2.variables
3.values-literals
4.operators
5.conditional and iterators


Helloworld

index.js

how to run code?

1.via browser

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=<device-width>, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="src/index.js"></script>
</body>
</html>

2.via node platform

$node src/index.js
///////////////////////////////////////////////////////////////////////////////////////////

Javascript is dynamic language:
 during runtime we can modify code.

Type system:

 How to represent data 

Strongly/Static typed languages

 The variable is verfied by the compiler during compile time

eg:
  int a =10;

  a ="hello" ; compiler will show error.

eg: c,c++,java,c#

Weakly/Dynamic typed languages


  The variable type is verifed by the runtime during execution

   def/var(keyword) variableName=value

 eg:
   var a =10;
   a="hello"
  it is perfectly valid

eg:
 js
/////////////////////////////////////////////////////////////////////////////////////////////

How to declare variables?

ES 5

var
Declares a variable, optionally initializing it to a value.

ES 6
let
Declares a block-scoped, local variable, optionally initializing it to a value.
const
Declares a block-scoped, read-only named constant.

this 
  keyword used to declare instance variables(objects)


syntax:

 keyword(var/let/const/this) variableName = value(literal)
 

//how to declare variable

var firstName="Subramanian";
console.log("First Name" + firstName);


literals : values based on it only the type of variable is identified during runtime.

literals types:

1.string
2.number
3.boolean
4.undefined
5.NaN
6.infinity
7.function
8.null
9.object

 var : is used in es 5
 let and const is used in es 6
 this : both version



Note: 
1.var,let,const all are same only but there are few differences, to be disucssed latter.
 var vs let and const.

2.In js ; is optional 


Point:

  if you are building javascript application based on es 6, recommandation is use "let and
const" always.

1.strings:

1.16 bit unicode charaters.

2.strings can be declared inside  "" or ''  or ``(back-tick) es 6 feature
   "" : inspired from java and c++
   '' : js specific notation.
  
3.string concatnation can be done
   +  and , and `foo ${variableName}`
//strings

var firstName = "Subramanian"
var lastName = 'Murugan';

console.log(" Name " + firstName + " " + lastName);
console.log(" Name ", firstName, " ", lastName);

//es 6 concatation syntax. `${variableName}` - interpolation

console.log(`Name ${firstName} ${lastName} `)

//Roles of `` notation : string concation,multi line string litreal.

var title = 'Game Portal'

var htmlDoc = "<html>" +
    "<head><title>" +
    title +
    "</title>" +
    "</head>" +
    "<body><h1>Sony Digital</h1>" +
    "</body></html>";
console.log(htmlDoc);

var newHtmlDoc = `
    <html>
      <head>
        <title>${title}</title>
    </head>
    <body><h1>Astro Gaming Site</h1>
    </body></html>
`;
console.log(newHtmlDoc);
//////////////////////////////////////////////////////////////////////////////////////////////

Numbers:

1.number size is 64 bit by default aka double.
2.It is IEEE 754 Standard.
//numbers

var qty = 10;
var price=1000000000000000000000000000;
console.log(`Qty ${qty}`);
console.log(`Price ${price}`)


Booleans:

1.represents true or false 
2.1 bit value.

//boolean

var isEnabled =true;
var isWorking=false;

console.log(`Enabled ${isEnabled}`)
console.log(`Isworking ${isWorking} `);



undefined:
..........
It is value, assigned to a variable, if no valid literal is assigned.


var firstName;
var price;
var qty;
console.log(`First Name ${firstName}`);
console.log(`price ${price} ${qty}`);

///////////////////////////////////////////////////////////////////////////////////////////

Related to Numbers:

1.NaN :Not a Number 

Not a Number but is number.
NaN represents error code.
NaN error code will come due to "numerical compuation failures".

Note:

 if you get NaN as out put, it is danger/toxic , it is runtime error, you need to fix.


When NaN will come?
 
//NaN use case 1; if you do numerical compuation against undefined

var qty; //undefined
var price = 1000;

var totalPrice = qty * price;
console.log(`Qty ${qty} price ${price} Total Price ${totalPrice}`)


Type conversion : string to number

types of Type conversion

1.implicit Type conversion
 js automatically converts string to number
2.explicit Type conversion
 js uses conversion utility apis to convert string to number.

//NAN

var qty; //undefined
var price = 1000;

var totalPrice = qty * price;
console.log(`Qty ${qty} price ${price} Total Price ${totalPrice}`)
//Type conversion

var count = "10"; // it string type but value is numerical value

//Type conversion happened here; implicit conversion
var totalCount = count * 10;
console.log(`Total Count ${totalCount}`);

//Type conversion using js built in api.
//double(64 bit) to 32 bit(integer)
var totalCounter = parseInt(count) * 10;
console.log(`Total Count ${totalCounter}`);
var totalCounterdouble = parseFloat(count,16) * 10;
console.log(`Total Count ${totalCounterdouble}`);


//Nan and type conversion
// here $100 is not numerical so during type conversion, error is thrown.
var stockValue = "$100";
var totalStock  = parseInt(stockValue) * 100;
console.log(`Total Stock ${totalStock}`);


2.infinity
div by 0


var price = 1000;
var avgPrice = price / 0;
//Avg Price Infinity
console.log(`Avg Price ${avgPrice}`);

////////////////////////////////////////////////////////////////////////////////////////////
Advanced booleans:
  
js supports booleans with value of true / false

In js every thing is true expect the following values.

Falsy Values:

1.boolean false
2.0
3.undefined
4.empty string "",''
5.NaN
6.null



//Advanced boolean

var firstName = "Subramaian";

if (firstName) {
    console.log("firstName found")
} else {
    console.log("firstName not found")
}
var lastName = "";

if (lastName) {
    console.log("lastName found")
} else {
    console.log("lastName not found")
}

var age = 18;

if (age) {
    console.log("age found")
} else {
    console.log("age not found")
}

var count = 0;

if (count) {
    console.log("count found")
} else {
    console.log("count not found")
}


var price;

if (price) {
    console.log("price found")
} else {
    console.log("price not found")
}


var totalPrice = price *100;

if (totalPrice) {
    console.log("totalPrice found")
} else {
    console.log("totalPrice not found")
}
/////////////////////////////////////////////////////////////////////////////////////////////

type of operator:
.................

1.returns type of variable in string format, in a smaller case

  "string","numbers"


//type of operator

var str = "hello";
var n = 100;
var u;
var b = true;
var notanumber = n * u;
var avg = 100 / 0;
//object ,null,function types to be discussed later.

console.log(`type of str ${typeof str}`)
console.log(`type of n ${typeof n}`)
console.log(`type of b ${typeof b}`)
console.log(`type of u ${typeof u}`)
console.log(`type of notanumber ${typeof notanumber}`)
console.log(`type of avg ${typeof avg}`)
///////////////////////////////////////////////////////////////////////////////////////////

Operators:

Assignment operators
Comparison operators
Arithmetic operators
Bitwise operators
Logical operators
String operators
Conditional (ternary) operator
Comma operator
Unary operators
Relational operators

///////////////////////////////////////////////////////////////////////////////////////////

Assignement

Assignment	x = y	   x = y

Addition assignment	x += y	x = x + y
Subtraction assignment	x -= y	x = x - y
Multiplication assignment	x *= y	x = x * y
Division assignment	x /= y	x = x / y
Remainder assignment	x %= y	x = x % y
Exponentiation assignment	x **= y	x = x ** y
Left shift assignment	x <<= y	x = x << y
Right shift assignment	x >>= y	x = x >> y
Unsigned right shift assignment	x >>>= y	x = x >>> y
Bitwise AND assignment	x &= y	x = x & y
Bitwise XOR assignment	x ^= y	x = x ^ y
Bitwise OR assignment	x |= y	x = x | y
Logical AND assignment	x &&= y	x && (x = y)
Logical OR assignment	x ||= y	x || (x = y)
Logical nullish assignment	x ??= y	x ?? (x = y)

//assignment operator

var x = 10;
var y = x;
console.log(`x ${x} y ${y}`);

var myvar = 10;
console.log(`Myvar value is ${myvar} and its type is ${typeof myvar}`)
//reassingment/ re initalization
myvar = "Hello"
console.log(`Myvar value is ${myvar} and its type is ${typeof myvar}`)

var a = 100;
var b = 100;
var c = a + b;
console.log(`C value is ${c}`)
var d = 10;
d = d + 1;
console.log(`d value is ${d}`)
d += 1
console.log(`d value is ${d}`)

///////////////////////////////////////////////////////////////////////////////////////////

Arthimetic Operators;
.....................

numerical operators
 +,-,*,/,%
 ++,--,
 ** - exponent

//arthimetic 

var x = 100;
var y = 100;
console.log(x + y)
console.log(x - y)
console.log(x * y)
console.log(x / y)
console.log(x % y)
console.log(x ** 2)

Bitwise operators and shift operators:
Note : not recommend to overuse in js, js need to convert 64 bit to 32 bit and starts operations.

Logical operators:
...................

Logical AND (&&)

expr1 && expr2	Returns expr1 if it can be converted to false; otherwise, returns expr2. Thus, when used with Boolean values, && returns true if both operands are true; otherwise, returns false.

Logical OR (||)	expr1 || expr2	Returns expr1 if it can be converted to true; otherwise, returns expr2. Thus, when used with Boolean values, || returns true if either operand is true; if both are false, returns false.

Logical NOT (!)	!expr	Returns false if its single operand that can be converted to true; otherwise, returns true.

Logical !! -  keeps the same value.

//logical operators
//
//|| or - based on boolean truth table

var isWorking = true;
var isEnabled = false;
var res = isWorking || isEnabled;
console.log(res);
//advanced or operator.

var name = "Subramaian";

/**
 * if first operand(name) is truthy, then result is first operand itself else
 * second operand
 */

var message = name || "Sorry";

console.log(message);

var price = 0;
var todayMinPrice = price || 10;

console.log(todayMinPrice);
///////////////////////////////////////////////////////////////////////////////
//And operator is opposit to or operator

var andRes = isWorking && isEnabled
console.log(andRes);

/**
 * if first operand(name) is truthy, then result is second operand  else
 * first operand
 */

message = name && "Sorry";
console.log(message);
todayMinPrice = price && 10;
console.log(todayMinPrice);
/////////////////////////////////////////////////////////////////////////////

//inverter !

var reached =true;
console.log(!reached)
var mycount =1000;
console.log(!mycount)

//dont invert !!
console.log(!!reached)
console.log(!!mycount)

///////////////////////////////////////////////////////////////////////////////////////

Conditional (ternary) operator
The conditional operator is the only JavaScript operator that takes three operands. The operator can have one of two values based on a condition. The syntax is:

condition ? val1 : val2

condition would be truthy or falsy

//tenary operators

var isEnabled = true;

var res = isEnabled ? "Enabled" : "Disabled";
console.log(res)

var name;
var found = name ? "Found" : "Not Found";
console.log(found)
/////////////////////////////////////////////////////////////////////////////////////////

Comparsional operators:
......................

1. less than <
2. less than or equal <=
3. greater than >
4. greater than or equal >=
5. ==, === equal
6. !=,!==

//relational operators

var x = 100;
var y = 10;
console.log((x < y) ? "less" : "not less")
console.log((x > y) ? "great" : "not great")
// == 

console.log((x == y) ? "equal" : "not equal")
console.log((x === y) ? "equal" : "not equal")

var a = "10";
var b = 10;
//test only value
console.log((a == b) ? "equal" : "not equal")
//test type + value : recommended operator ===
console.log((a === b) ? "equal" : "not equal")

console.log((a != b) ? "equal" : "not equal")
console.log((a !== b) ? "equal" : "not equal")
/////////////////////////////////////////////////////////////////////////////////////////////

Advanced operators

1.typeof - to know the type of variable
2.new  -  to allocate memory ; object creational operator
3.instance of - to know the parent type
4. in -  used with collection iterators
5. "." - object access operators
6. [] -  used to represent arrays elements &&  used to access object properties
7.{} -  to represent block of statements
8. of -  used with for loop
/////////////////////////////////////////////////////////////////////////////////////////////

Conditional statments and Control Structures:
..............................................

1.Decision making:

 if
 if..else
 if..elseif
 if ..elseif..else
 switch...case

statements:
  break;
 
//if and else

var a = 100;
var result='';
if (a > 0) {
    result = 'positive';
} else {
    result = 'NOT positive';
}
console.log(result)

..if..else if
var x = 10;

if (x > 50) {
    console.log("X is greater than 50")

} else if (x > 5) {
    /* do something */
    console.log("X is greater than 5")
} else {
    /* do something */
    console.log("No match found")
}
.........................................................................................



switch (expression) {

  case value1:
    //Statements executed when the
    //result of expression matches value1
    [break;]
  case value2:
    //Statements executed when the
    //result of expression matches value2
    [break;]
  ...
  case valueN:
    //Statements executed when the
    //result of expression matches valueN
    [break;]
  [default:
    //Statements executed when none of
    //the values match the value of the expression
    [break;]]
}

var expr = 'Papayas';
switch (expr) {
    case 'Oranges':
        console.log('Oranges are $0.59 a pound.');
        break;
    case 'Mangoes':
    case 'Papayas':
        console.log('Mangoes and papayas are $2.79 a pound.');
        // expected output: "Mangoes and papayas are $2.79 a pound."
        break;
    default:
        console.log(`Sorry, we are out of ${expr}.`);
}

//////////////////////////////////////////////////////////////////////////////////////////

Iterators -  loops;

1.for
2.while
3.do..while
4.for..in
5.for..of

var str = '';

for (var i = 0; i < 9; i++) {
    str = str + i;
}

console.log(str);

var n = 0;

while (n < 10) {
    console.log(n)
    n++;
}

console.log(n);
// expected output

var result = '';
var i = 0;

do {
    i = i + 1;
    result = result + i;
} while (i < 5);

console.log(result);
// expected result: "12345"

/////////////////////////////////////////////////////////////////////////////////////////////

Functions:
..........

What is function?

 function is block, inside we can define the logic.

syntax :

function declaration

 function functionName(args) {

   //block of code
 }

function invocation.


//define basic functions

function sayHello() {
    //block of code
    console.log('hello javascript')
}
//function invocation.
sayHello();

////////////////////////////////////////////////////////////////////////
The function with logic:
function add() {
    var a = 10;
    var b = 20;
    var c = a + b;
    console.log(`The addition ${c}`)
}
add()
/////////////////////////////////////////////////////////////////////////////////////////////
//parameters and args:
.....................

-javascript is type less , so args can take any type of literal

//function args and parameters
//message is arg
function sayHello(message) {
    console.log(message);
}
//pass value is here parameter
sayHello('Hello');
sayHello(10)
sayHello(true)
sayHello()
sayHello(NaN)


function add(a, b) {
    var result = a + b;
    console.log(result)
}
add(10, 10);
add()
add("10", "20")
add("10", 10)
add(10)
add(8, 8, 10)

function multiply(a, b) {
    //default value initalization if variables having undefined 
    //this is es 5 style
    a = a || 0;
    b = b || 0;
    var res = a * b;
    console.log(res);
}
multiply(10, 10)
multiply()
//es 6 style of default value initalizaiton
//default args
function multiplyE6(a = 0, b = 0) {
    var res = a * b;
    console.log(res);
}
multiplyE6(18, 10)
multiplyE6()
/////////////////////////////////////////////////////////////////////////////
//what if i want to pass more parameters, i dont know in advance how many args 
//i pass
function logger() {
    //arguments : built in variable, holding all parameter values
    console.log(arguments) //es 5 syntax
}
logger('hello')
logger('hello', 'greet')
logger('hello', 'welldone', 'good', 'js')

//Rest Operator : ... es 6 syntax to replace "arguments"
function sum(...numbers) {
   console.log(numbers)
}
sum(1, 2, 4);
sum(1, 2, 3, 4, 5, 6, 7, 8)

//////////////////////////////////////////////////////////////////////////////////////////////

What(literal) can be passed as parameter?

All literals can be passed as parameter.
 -strings,numbers,boolean,undefined,function,null,object,nan,infinity.


functions types:

1.user defined functions
  eg ; sayHello,add,compute
2.global built in functions
   functions are defined by js language.
 parseInt,parseFloat,isNaN,eval,isFinite,encodeURI(),decodeURI...


function compute(res) {
    if (isNaN(res)) {
        console.log('SOrry computation is failed')
    } else {
        console.log(res);
    }
}
var x = 10;
var y = 20
compute(x * y)
x = "$10"
compute(x * y)

function findAvg(a, b) {
    var res = a / b;
    if (res === Infinity) {
        console.log('div by 0 ')
    } else {
        console.log(res);
    }
}
findAvg(10, 2)
findAvg(10, 0)
////////////////////////////////////////////////////////////////////////////////////////////

How to return values from the function?

function can return any literal
///function returns

///function returns

function sayHello() {
    return 'Hello';
}
console.log(sayHello())

function sayHai() {
    var message = 'hai'
    return message;
}
console.log(sayHai())

function sayGreet() {
    return;
}
console.log(sayGreet())

function add(a = 1, b = 1) {
    return a + b; //expression
}
console.log(add(1, 2))

function validate(username = 'root', password = 'root') {
    if (username === 'admin' && password === 'admin') {
        return true;
    }
    return;
}
validate() ? console.log('success') : console.log('failed')
validate('admin','admin') ? console.log('success') : console.log('failed')

////////////////////////////////////////////////////////////////////////////////////////////

How to implement recurssive functions?
fact

function factorial(n) {
    if ((n === 0) || (n === 1))
        return 1;
    else
        return (n * factorial(n - 1));
}
console.log(factorial(5))


//////////////////////////////////////////////////////////////////////////////////////////

functional Programming:
.......................

functional programming is one of the programming style/paradigm. introduced in 1950's.


Lambda calculus:

 Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution.
 It was introduced by the mathematician Alonzo Church in the 1930s as part of his research into the foundations of mathematics.

Lambda calculs Implementation:

The Programming languages which implements "lambda Calculus theory" called "Functional programming".


Lambda expressions the programs construction through "functions" -->f()

The languages which implements lambda Calculus
 ->LISP
 ->Scheme
 ->haskell

etc........

style vs pure:
..............
  if a pl implements 100% principles of an functional paradigm-lambda calculs, 
  those languages called "Pure"

  if a pl implements not all principles or partially,   those languages called "style".


Functional Programming Principles:

what is function? - 
  according lambda calculs , function is representation of computation. which receivies input,process it, return it.- unit of operation

-Functions are "first-class citizen” : function abstraction.
-Functions can be assigned to variables
-Composition of functions 
-Higher order functions
-Functions can be passed as parameters
-Functions can be returned as a result
-Functions without side effects (referential transparency) ; pure functions
-Persistent (immutable) data structures
-Algebraic data types (sum and product types)
-Pure functional programming has no loops(for..while), they support only recurrsion


Does javascript is pure functional programming language?

No!.
javascript is "functional style" programming language.

According to functional programming,
  "functions" are values(literals).

Since function is value(literal) like strings and numbers, can be assigned to a variable
 eg:
  var a=10;
  var name="subramanian"
  var f = function(){} - valid

Since function is value(literal) like strings and numbers, can be passed around function.
...........................................................................................

Since function is value(literal) like strings and numbers, can be assigned to a variable.
That variable can be used to invoke that function.


How to declare functions?

//how to declare functions and how to call it.

//way -1 
function sayHello(name) {
    console.log('hello', name);
}
sayHello('subramanian');

//function is literal. you can assign to a variable.
var hello = sayHello;
console.log(hello);
hello('ram');
/////////////////////////////////////////////////////////////////////////////
//inline function declaration.
//way -2
var hai = function sayHai(name) {
    console.log('hi', name);
};
hai('subu')
//sayHai()

//way -3 : anonymous function ; function without name
var greet = function (name) {
    console.log('greet', name);
};
greet('subu')
//////////////////////////////////////////////////////////////////////////////////////////////

Function as Parameter:
....................

functions can be passed as parameter to another function.

//function as parameter to another function.

function add(a, b) {
    var c = a + b;
    console.log(c);
}
//passing parameters
//via variables
var x = 10;
var y = 10;
add(x, y);
//hardcoded values
add(10, 20)
//////////////////////////////////////////////////////////////////////////////////
//hai = greet = 
function sayGreet(callback) {
    var status = callback('subramanian');
    console.log(status);
}
//regular function
function sayHello(name) {
    console.log('hello', name)
    return 'done'
}
//via variable
var greet = function (name) {
    console.log('Hai', name)
    return 'done'
};
sayGreet(greet)

//hardcode values
sayGreet(function (name) {
    console.log('hai hai')
    return 'done'
});
sayGreet(sayHello)
/////////////////////////////////////////////////////////////////////////////////////////////

How to declare reciver function in literal pattern?


var sayGreet = function (callback) {
    var status = callback('subramanian');
    console.log(status);
}
//hardcode values
sayGreet(function (name) {
    console.log('hai hai')
    return 'done'
});

///////////////////////////////////////////////////////////////////////////////////////////

How to pass more than one parameter as function?


// function login(userName, password, success, failure) {
//     if (userName === 'admin' && password === 'admin') {
//         //send success result via function to the caller
//         success(`Login success : ${userName}`)
//     } else {
//         failure('Login failed');
//     }
// }
var login = function (userName, password, success, failure) {
    if (userName === 'admin' && password === 'admin') {
        //send success result via function to the caller
        success(`Login success : ${userName}`)
    } else {
        failure('Login failed');
    }
};

login('admin', 'admin', function (message) {
    console.log(message)
}, function (err) {
    console.log(err)
});


login('foo', 'admin', function (message) {
    console.log(message)
}, function (err) {
    console.log(err)
});
/////////////////////////////////////////////////////////////////////////////////////////////

Best practice: test whether you have passed function?

function doStuff(callback) {
    if (typeof callback === 'function') {
        callback();
    } else {
        console.log('Wrong type ')
    }

}
doStuff(function () {
    console.log('done')
})
doStuff('foo')
//////////////////////////////////////////////////////////////////////////////////////////////

How to return function from another function?

inner functions:
 function is declared with in another function


Note:

any declaration inside function (exect instance members), not visible outside that function
-local scope.



function outter() {
    var myvar='foo'
    console.log('outter')
    function inner() {
        console.log('inner')
    }
}
outter();
 inner();
//console.log(myvar)

if you run the above code , you will get error message
inner();
^

ReferenceError: inner is not defined
    at Object.<anonymous> (C:\session\astro\2021\js-apps\src\index.js:20:1)
    at Module._compile (internal/modules/cjs/loader.js:959:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)
    at Module.load (internal/modules/cjs/loader.js:815:32)
    at Function.Module._load (internal/modules/cjs/loader.js:727:14)
    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)
    at internal/main/run_main_module.js:17:11


The function is not visible outside, similary the myvar variable.


How to call/invoke the innerfunction?

Two soultions:

1.within in outter function

function outter() {
    var myvar='foo'
    console.log('outter')
    function inner() {
        console.log('inner')
    }
    //calling inside outter function
    inner();
}
outter();

2.return the that function outside and call it

way-1
function outter1() {
    var myvar = 'foo'
    console.log('outter')
    function inner() {
        console.log('inner')
    }
    return inner;
}
var res = outter1();
console.log(res);
res();

way-2

function outter1() {
    var myvar = 'foo'
    console.log('outter')
    return function inner() {
        console.log('inner')
    }
}
var res = outter1();
console.log(res);
res();

way-3 - return anonymous function
function outter1() {
    var myvar = 'foo'
    console.log('outter')
    return function () {
        console.log('inner')
    }
}
var res = outter1();
console.log(res);
res();


way-4; calling function refactoring

function outter1() {
    var myvar = 'foo'
    console.log('outter')
    return function () {
        console.log('inner')
    }
}
// var res = outter1();
// console.log(res);
// res();
//refactoring calling syntax
outter1()();


can we pass any parameters to the inner function from outside?

function outter1() {
    var myvar = 'foo'
    console.log('outter')
    return function (name) {
        console.log('inner',name)
    }
}
var res = outter1();
res('subramanian');
//refactoring calling syntax
outter1()('subramanian');

can inner function return value to outside?

function outter1() {
    var myvar = 'foo'
    console.log('outter')
    return function (name) {
        return `inner ${name}`;
    }
}
var res = outter1();
console.log(res('subramanian'));
//refactoring calling syntax
console.log(outter1()('subramanian'));


can outter function be an variable pattern?

var outter1 = function () {
    console.log('outter')
    return function (name) {
        return `inner ${name}`;
    }
};
var res = outter1();
console.log(res('subramanian'));
//refactoring calling syntax
console.log(outter1()('subramanian'));
//////////////////////////////////////////////////////////////////////////////////////////////

functions related concepts:
..........................

1.async programming
2.closure
3.curry functions /higher order function.
4.recurssive functions
5.anonmous functions
6.IIFE functions- immediately invoked function expression.
7.ES 6 Functions -arrow function.

IIFE:
 IT is self executing anonmouys function.
 The function executes itself.
 It is very usefull for initalization applications.

//IIFE function., no name.


(function () {
    console.log('app is initalied')
})();
// iife with params

(function (name = 'default') {
    console.log(name);

})('foo');

//iife with return value

var result = (function (name = 'default') {
    return name;
})('foo');
console.log(result);
///////////////////////////////////////////////////////////////////////////////////////

Arrow functions:

An arrow function expression is a compact alternative to a traditional function expression,
but is limited and cant be used in all situations.

Arrow differences and limitations:
..................................

1.does not have its own bindings to "this or super".
2.It should not be used as methods in objects.
3.It does not have arguments keywords
4.cant be used as constructors
5.cant use "yield" keyword within its body.

Basic arrow 


//es 5 function expression syntax
var hai = function () {
    console.log('hai');
};
hai();
//arrow will replace the above one.

var hello = () => {
    //function body
    console.log('hello');
};
hello();

//if function body has one line of code, we can remove {}
hello = () => console.log('hello');
hello();

///arrow and parameters ; more parameter with default value.

var add = (a = 0, b = 0) => {
    var result = a + b;
    console.log('add', result);

};
add(10, 10);
///arrow and parameters ; single parameter with out default value,you can remove()
var getStock = value => console.log(`Stock Value ${value}`)
getStock(100)
//////////////////////////////////////////////////////////////
//arrow functions and return
var getName = () => {
    return 'Subramanian';
};
console.log(getName())
//if function has only return statement, you can remove {} and return statement
getName = () => 'Subramanian';
console.log(getName())

/////////////////
//if function recieves single input,without default value and return the same
var myfunc = input => input;
console.log(myfunc('hello'))

/////////////////////////////////////////////////////////////////////////////////////////

Arrow functions and function as parameter and IIFE Functions
//function as parameter

// function sayGreet(callback) {
//     callback();
// }

var sayGreet = callback => {
    callback('subramanian');
}
var hello = name => console.log('hello', name)
sayGreet(hello);
sayGreet(name => console.log('hello arrow'));

/////////////////////////////////////////////////////////////////////////////

// function outter() {
//     console.log('outer')
//     return function inner() {
//         console.log('inner')
//     }
// }
// function outter() {
//     console.log('outer')
//  return () => {
//         console.log('inner')
//     }   
// }
// function outter() {
//     console.log('outer')
//     return () => console.log('inner')

// }
// var outter = () => {
//     console.log('outer')
//     return () => console.log('inner')
// }
var outter = () => () => console.log('inner')
outter()();

(() => console.log('app is initalied'))();

((name = 'default') => console.log(name))('foo');
var result = ((name = 'default') => name)('foo');
console.log(result);
/////////////////////////////////////////////////////////////////////////////////////////////

Object based(oriented) Programming:
...................................

What is oo programming?

 OO is another paradigm/style of writing application.

What is Object?

 Views of Object :

1.Domain - Problem
    Object could be anything, but that should be relavant to the problem domain - graddy booch.

eg:
 if you are building health care app, marks are not relavent to the domain. according to
health care students marks are not object.

Object Oriented Principles:
...........................

1.Abstraction
2.Encapsulation
3.Hierarchy
4.Typing
5.Modularity
----------------------
6.Concurrency
7.Persistency

    
2.implementation

-What is object?
 Object is memory represenation.
 Object is collection of properties
 Property could be variables having primitive values, methods(functions)
 Property could be another object

Pure Object oriented Programming languages(c++,java,C#) class based languages.

class is fundmental representation  of object properties in source code.
Without class no object created.
////////////////////////////////////////////////////////////////////////////////////////////

Stages of Object creation:
..........................

0. source code
  we classes to represent object properties
 eg:
  Customer.java
   class Customer{
       int id;
       String name;
       public double calculateTax(){
           return 100.89;
       }
   }
1.compile time
  Customer.class

  class Customer{
       int id;
       String name;
       public double calculateTax(){
           return 100.89;
       }
     
   }
  +
  extra code
     memory allocation information table- Virtual table-array of information.

  
2.runtime time

  Customer.class--loaded into runtime----Run time will start allocating memory
  --Object(Runtime representation of class)


Once object is created we can do three things

1. we set values on object properties
2. we get values on object properties
3. We can execute methods on object
..............................................................................................

Static and dynamic language:
............................  

static languages fixes object layout during compile time itself, using virtual table.
during runtime we cant alter the object layout.

dynamic languages dont have compile time object layout, does not use "Virtual table"
rather who uses datastructures -  dictionary(key-value) , during runtime we can alter object


Js and Objects:

1.js does not use classes for creating object.uses functions
2.js objects are dynamic
3.js objects are allocated inside heap memory of js engine.
4.IN js everthing object almost.
    -Js code itself object - context - Execution Context.
5.objects can be created in many ways

   1.using functions
   2.using literals
   3.using Object.create method
   4.using es 6 class

Object Properties:

 1.variables - instance variables
 2.methods - instance methods
 3.constructors - function to initalize the variables.

how to declare object properties?

 this keyword  - inside function
 super keyword
 without any keyword.


Note: 

 functions are first class citizens 
   -used to encapsulate logic -
   -used to encapslate object properties

how we can change function rolls
   function myfun(){}

   myfun()---regular execution
  new myfun() - constructor execution- object creation.

Recommendations:

 1.in case if function is used for logic , naming convention could be
    verb+Noun -  doStuff() / verb - calculate().
 2.in case if function is used for object , naming convention could be
    Noun-  Employee,Customer


..........................................................................................

How to create object?
//

function Employee() {
    //object properties
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;

}
//emp is reference variable,points the object location.
var emp = new Employee();
console.log(emp)

how to access/get object properties?

we have operator

 "." operator
 "[]" operator

//

function Employee() {
    //object properties
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;

}
//emp is reference variable,points the object location.
var emp = new Employee();
console.log(emp)
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary}`)
console.log(`Id ${emp['id']} name ${emp['name']} Salary ${emp['salary']}`)

how to define methods?
//

function Employee() {
    //object properties
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;
    //methods : via function
    this.calculateLeave = function (leave = 1) {
        return leave;
    }


}
//emp is reference variable,points the object location.
var emp = new Employee();
console.log(emp)
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
console.log(`Id ${emp['id']} name ${emp['name']} Salary ${emp['salary']}`)

/////////////////////////////////////////////////////////////////////////////////////////////

How many objects you can create out of single function?

many objects, subject to memory .

Each object has its own memory location.

//

function Employee() {
    //object properties
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;
    //methods : via function
    this.calculateLeave = function (leave = 1) {
        return leave;
    }


}
//emp is reference variable,points the object location.
var emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
var emp1 = new Employee()
console.log(`Id ${emp1.id} name ${emp1.name} Salary ${emp1.salary} leave ${emp1.calculateLeave(12)}`)

///////////////////////////////////////////////////////////////////////////////////////////

How to reuse one reference to create multiple objects and how to use them?.

Null:
Null is object, having no properties.
used to identicate that the reference variable is going to hold objects in futures
used to report meaningfull errors

//

function Employee() {
    //object properties
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;
    //methods : via function
    this.calculateLeave = function (leave = 1) {
        return leave;
    }


}
var emp = null;
console.log(typeof emp);
emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
/////////////////////////////////////////////////////////////////////////////////////////////

State initalization:(instance variable)
.......................................

1.hardcoded inside function
    this.id = 1;
    this.name = 'Subramanian';
    this.salary = 10000;

2.after object creation
var emp = null;
console.log(typeof emp);
emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
//state initalization
emp.id = 9000;
emp.name = 'Ram';
emp.salary = 88888;
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)


3.during object creation; consturctor parameters

//

function Employee(id = 1, name = 'Subramanian', salary = 10000) {
    //object properties
    this.id = id // 1;
    this.name = name //'Subramanian';
    this.salary = salary //10000;
    //methods : via function
    this.calculateLeave = function (leave = 1) {
        return leave;
    }


}
var emp = null;
emp = new Employee()
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
emp = new Employee(888, 'foo', 87666) //constructor parameters
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)
emp = new Employee(888, 'foo', 87666) //constructor parameters
emp.id = 1200
emp.name = 'bar';
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} leave ${emp.calculateLeave(12)}`)

/////////////////////////////////////////////////////////////////////////////////////////

Can Object return instance variables via instance methods?

Yes
//

function Employee(id = 0, name = '', salary = 0) {
    //object properties
    this.id = id // 1;
    this.name = name //'Subramanian';
    this.salary = salary //10000;
    this.bonus = 2.5;
    //methods : via function
    this.calculateBonus = function () {
        return this.salary * 2.5 / 100
    }
    this.calculateAnnualSalary = function () {
        return this.calculateBonus() + this.salary;
    }
}
var emp = null;
emp = new Employee(1, 'Subramanian', 49500)
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} Bonus ${emp.calculateBonus()} Annual salary ${emp.calculateAnnualSalary()}`)

///////////////////////////////////////////////////////////////////////////////////////////
Encasulation:

js is very weak by providing  code sharing feature.

if you declare any thing inside function, you cant access outside with help of var declartion /regular function declaration.
 if you do so inside object template, then those things are called private variables/methods


//

function Employee(id = 0, name = '', salary = 0) {
    //object properties
    this.id = id // 1;
    this.name = name //'Subramanian';
    this.salary = salary //10000;
    //private variable
    var bonus = 2.5;
    //methods : via function
    this.calculateBonus = function () {
        return computeBonus();
    }
    this.calculateAnnualSalary = function () {
        return this.calculateBonus() + this.salary;
    }
    var tempSalary = this.salary;
    //private function
    // function computeBonus() {
    //     console.log(this.salary);
    //     return this.salary * bonus / 100
    // }
    function computeBonus() {
        return tempSalary * bonus / 100
    }
}
var emp = null;
emp = new Employee(1, 'Subramanian', 49500)
console.log(`Id ${emp.id} name ${emp.name} Salary ${emp.salary} Bonus ${emp.calculateBonus()} Annual salary ${emp.calculateAnnualSalary()}`)
///////////////////////////////&&&&&&&&&&&&&&&&&&&&&&&&&&////////////////////////////////////

Hierachy:
 Object relationship. In applications objects collabrate each other.How objects can share their code(data,methods).

Types of Hierachy:
1.HAS-A - Composition/association
2.IS-A  -  Inheritance.

//has a 

function Phone(mobileno = "1234567890") {
    this.mobileno = mobileno
}

function Address(doorno = "doorno", street = "street", city = "city", state = "state", zip = "zip", mobileno = new Phone()) {
    this.doorno = doorno;
    this.street = street;
    this.city = city;
    this.state = state;
    this.zip = zip;
    this.mobileno = mobileno;
}

function Employee(id = 0, name = "defaultName", salary = 0.0, address = new Address()) {
    this.id = id;
    this.name = name;
    this.salary = salary;
    //address - doorno,street,city,state,zipcode-has-a 
    this.address = address;
}
//how to associate objects

var emp = null;

emp = new Employee();
console.log(emp);

var phone = new Phone("9003407867")
var address = new Address("10/5", "gandhi street", "Coimbatore", "Tamil Nadu", "600 001", phone)
emp = new Employee(1, "Subramanian", 1000, address);
console.log(emp);

emp = new Employee(1, "Subramanian", 1000, new Address("10/5", "gandhi street", "Coimbatore", "Tamil Nadu", "600 001", new Phone("9003407867")))

/////////////////////////////////////////////////////////////////////////////////////
  
IS-A: Inheritance:
.................

What is inheritance?

  It is type of relationship between objects.
  It is relatiship type.

Why inhiertance?
  ->To achive high degree of code resuablity.
    ->code- variables,functions -Object(variables+methods) : classes,interfaces(java)
  ->Keep code in one object and share across mutliple objects without redefining it

Java script inheritance is completly different from "c++/java" based languages.

"C++/java" inheritance is called "classical inheritance" , where javascript inheritance
is called "Prototypical inheritance".

classical vs prototypical:
.........................

1.classical inheritance is "class" based inheritance.
   inheritance is decided during compile time.

eg: java
source code

A.java
class A{
  //object properties
  void doStuff(){
  }
}
B.java
class B extends A {

}

compiled code:
A.class
class A{
  //object properties
  void doStuff(){
  }
}
B.class
class B extends A {
 //object properties
  void doStuff(){
  }
}

2.prototypical inheritance is "object" based inheritance.

Code sharing happens during runtime only.

Object A (code) ------ Object B  -> try to access Object A property from b.

Javascript and "prototypical  inheritance":
...........................................

Prototype:

  Every object, when is created, receives its prototype. If the prototype is not set explicitly, objects receive default prototype as their inheritance object.


The prototype objects are used to implement inheritance with the mechanism of 
"dynamic dispatch-property lookup"

A prototype is a "delegation object" used to implement prototype-based inheritance.

Delegation/Proxy Design pattern:
...............................

Use case 1
The job is not done by the Program(Object) itself rather dispatch/delegates to other objects
 eg: async arch.

Use case 2
In js Prototype is delegation object used for shared properties.(Inheritance).
 This type of inheritance is called as "Prototypical  inheritance"
////////////////////////////////////////////////////////////////////////////////////////////

How to verify the Default Prototype Object?


function Employee(id = 0, name = "foo") {
    this.id = id;
    this.name = name;
}
var emp = new Employee();
console.log(emp);

Test this code in browser.

Employee
id: 0
name: "foo"
__proto__:
constructor: ƒ Employee(id = 0, name = "foo")
__proto__:
constructor: ƒ Object()
hasOwnProperty: ƒ hasOwnProperty()
isPrototypeOf: ƒ isPrototypeOf()
propertyIsEnumerable: ƒ propertyIsEnumerable()
toLocaleString: ƒ toLocaleString()
toString: ƒ toString()
valueOf: ƒ valueOf()
__defineGetter__: ƒ __defineGetter__()
__defineSetter__: ƒ __defineSetter__()
__lookupGetter__: ƒ __lookupGetter__()
__lookupSetter__: ƒ __lookupSetter__()
get __proto__: ƒ __proto__()
set __proto__: ƒ __proto__()


Prototype chain: 
................
    A prototype chain is a finite chain of objects used to implement inheritance and shared properties.

  Employee ----->Prototype-----Object----->null


How to share code in Prototype and how to share it across multiple objects.


function Employee(id = 0, name = "foo") {
    this.id = id;
    this.name = name;
}
var emp = new Employee();

//
console.log(`Id ${emp.id}`);
console.log(`Name ${emp.name}`);
//?
console.log(`Salary ${emp.salary}`);

when you run the above code , you will get output like below.

Id 0
Name foo
Salary undefined

how salary got undefined?

Delegation: a mechanism used to resolve a property in the inheritance chain. The process happens at runtime, hence is also called dynamic dispatch

"The rule is very simple:
   "if a property is not found in the object itself, there is an attempt to resolve it in the prototype; in the prototype of the prototype, etc. — until the whole prototype chain is considered."

how to add propery in the current object?

inside object template

function Employee(id = 0, name = "foo") {
    this.id = id;
    this.name = name;
}
but js is dynamic language : you can add,update,delete,iterate properties during runtime, even
after object is created : "Object Augmentation".
//?
//object augmentation: add property
emp.salary = 10000;

//object augmentation: update property
emp.name ="subramanian"

add vs update:
...............

 if property exits in the chain, update happens, if not then add will happen.


How to delete property? using delete operator.

delete emp.department;
*******************************************************************************************

Shared Properties:
...................

 Properties can be shared across multiple "instances"

instance keeps its own data.

lets assume if i create 10 instance out of "Employee" , each instance data will be different.



function Employee(id=0,name="foo"){
    this.id=id;
    this.name = name;
}
//create two instances

var emp1 = new Employee();
emp1.id =1000;
emp1.name="Subramanian"
console.log("employee 1 data")
console.log(`Id ${emp1.id}`);
console.log(`Name ${emp1.name}`);

var emp2 = new Employee();
emp2.id =22222;
emp2.name="Ram"
console.log("employee 2 data")
console.log(`Id ${emp2.id}`);
console.log(`Name ${emp2.name}`);


i want to have common data(Shared Properties) for both instances
................................................................

You have to add properties inside "Prototype" Object.

How to get Prototype Object?

Function.prototype


function Employee(id = 0, name = "foo") {
    this.id = id;
    this.name = name;
    this.bouns = 999;
}

//get Prototype of employee
console.log(Employee.prototype)

//augment Prototype Object
Employee.prototype.salary = 900.00;
Employee.prototype.calculateBonus = function () {
    return this.bouns;
}
Employee.prototype.calculateSalary = function () {
    return this.salary * 100;
}
//create two instances
var emp1 = new Employee();
emp1.id = 1000;
emp1.name = "Subramanian"
console.log("employee 1 data")
console.log(`Id ${emp1.id}`);
console.log(`Name ${emp1.name}`);
console.log(`Salary ${emp1.salary}`);
console.log(`Bouns ${emp1.calculateBonus()}`);
console.log(`totalsalary ${emp1.calculateSalary()}`);



var emp2 = new Employee();
emp2.id = 22222;
emp2.name = "Ram"
console.log("employee 2 data")
console.log(`Id ${emp2.id}`);
console.log(`Name ${emp2.name}`);
console.log(`Salary ${emp2.salary}`);
console.log(`Bouns ${emp2.calculateBonus()}`);
console.log(`totalsalary ${emp2.calculateSalary()}`);

Lookup chain:
Prop--->parent 1--->parent 2--->parent 3--->parent n-- | null

object.__proto__:Object
           |
           object.__proto__:Object
  	   |
	           object.__proto__:null

If property not found any object in the chain, it will return undefined.
 obj.x--->not p-->not p-->Object-->undefined
/////////////////////////////////////////////////////////////////////////////////////////

Explicit inheritance:

 what if i dont want my parent object would be "Prototype".

eg:
  Create Class SavingsAccount---inherit---ACCOUNT---Prototype----Object

If you want link two objects 
  ->__proto__ you can use but it is not ECMA Standard
  ->Object.create is utilty api used to link two objects -ECMA     Standard


..................................................................................

How to link two objects:

Child.prototype  = Object.create(Parent.prototype)
//linking objects: inheritance;

//base class 
function Person(name = 'default') {
    console.log('Person is called')
    this.name = name;
}
Person.prototype.sayGreet = function () {
    return 'greet'
}
//child class
function Employee(name) {
    //calling super class constructor.
    Person.call(this,name); //binding base class and child class
    console.log('Employee is called')
}
//Linking Objects : establishing inheritance:
Employee.prototype = Object.create(Person.prototype);

var emp = new Employee("Subramanian");
console.log(emp.name);
console.log(emp.sayGreet())


var emp1 = new Employee();
console.log(emp1.name);
console.log(emp1.sayGreet())
//////////////////////////////////////////////////////////////////////////////////////////////

Object creation using literal Pattern:
......................................

1.no function is used to create object
2.object can have properties and methods
3.literal objects dont have prototypes.
4.literal objects can be inherited, default base object is "object".
5.litreal objects can be nested- has-a.
6.literal objects do have constructors.

syntax:

var refVariable = {
 prop1:literal,
 prop2:literal,
 etc....
};



var emp = {
    id: 1,
    name: 'subramanian',
    salary: 1000,
    calculateSalary: function () {
        return this.salary * 10;
    }
};
console.log("Literal Object details")
console.log(`id ${emp.id}`)
console.log(`name ${emp.name}`)
console.log(`Salary ${emp.salary}`)
console.log(`Total Salary ${emp.calculateSalary()}`)


//state initalization; no constructors

var emp = {
    id: 1,
    name: 'subramanian',
    salary: 1000,
    calculateSalary: function () {
        return this.salary * 10;
    }
};

emp.name = 'karthik'
emp.salary = 9000;
console.log("Literal Object details")
console.log(`id ${emp.id}`)
console.log(`name ${emp.name}`)
console.log(`Salary ${emp.salary}`)
console.log(`Total Salary ${emp.calculateSalary()}`)
/////////////////////////////////////////////////////////////////////////////////////////////
How to implement hierachy?

//has-a ; nested object

var emp = {
    id: 1,
    name: 'subramanian',
    salary: 1000,
    address: {
        street: '10th',
        city: 'coimbatore',
        phone: {
            mobileno: '900897878'
        }
    },
    calculateSalary: function () {
        return this.salary * 10;
    }
};

console.log("Literal Object details")
console.log(`id ${emp.id}`)
console.log(`name ${emp.name}`)
console.log(`Salary ${emp.salary}`)
console.log(`Address ${emp.address.city} ${emp.address.phone.mobileno}`)
console.log(`Total Salary ${emp.calculateSalary()}`)

/////////////////////////////////////////////////////////////////////////////////////////////

How to implement is-a relationship in literal object?

-parent object
  unlike functions, literals has no prototype object.
  Immediate parent object is "Object".



var parent = {
    color: 'red'
}
var child = {
    size: 10
}
child.__proto__ = parent;
console.log(child.size, child.color);

var product = {
    color: 'pink'
}
var item = Object.create(product);
item.size = 100;
item.price = 98;
item.qty = 90;
console.log(item.color,item.size,item.price,item.qty)
///////////////////////////////////////////////////////////////////////////////////////////////
                                   ES 6 Classes
/////////////////////////////////////////////////////////////////////////////////////////////

1.ES 6 classes are alternate syntax for function based objects.
2.ES 6 classes are simple to use, abstracts many complixites
3.It is easy to understand , debug,clear code for oo developers
4.All es 6 classes are functions only internally.
5. which has keywords class,"constructor",extends,this,super.
6. inside class we can declare instance variables, methods without this keyword.
7.object creation syntax remains same.


//es 6 classes

class Employee {
    //instance variables
    id = 0;
    name = 'foo';
    //methods
    calculateSalary() {
        return 100
    }
}
//create object
var emp = new Employee();
console.log(emp.id,emp.name,emp.calculateSalary())

state initalization:
//es 6 classes

class Employee {
    //instance variables
    // id = 0;
    // name = 'foo';
    constructor(id = 0, name = 'foo') {
        this.id = id
        this.name = name;
    }
    //methods
    calculateSalary() {
        return 100
    }
}
//create object
var emp = null;
emp = new Employee();
emp.id = 1;
emp.name = 'bar'
console.log(emp.id, emp.name, emp.calculateSalary())

emp = new Employee(2, 'subramanian');
console.log(emp.id, emp.name, emp.calculateSalary())

Arrow functions inside classes:
//es 6 classes

class Employee {
    //instance variables
    // id = 0;
    // name = 'foo';
    constructor(id = 0, name = 'foo') {
        this.id = id
        this.name = name;
    }
    //methods
    calculateSalary() {
        return 100
    }
    calculateLeave = () => 10;
}
//create object
var emp = null;
emp = new Employee();
emp.id = 1;
emp.name = 'bar'
console.log(emp.id, emp.name, emp.calculateSalary(),emp.calculateLeave())

emp = new Employee(2, 'subramanian');
console.log(emp.id, emp.name, emp.calculateSalary(),emp.calculateLeave())

//////////////////////////////////////////////////////////////////////////////////////////

Hierachy inside classes:
........................

//has-a

class Product {
    constructor(pid = '00', pname = 'foo') {
        this.pid = pid;
        this.pname = pname
    }
}
class Order {
    constructor(orderId = 'A000', product = new Product()) {
        this.orderId = orderId;
        //has-a
        this.product = product;
    }
}
var order = null;
order = new Order();
console.log(order.orderId, order.product.pname)

order = new Order(1, new Product(90, 'myproduct'));
console.log(order.orderId, order.product.pname)
/////////////////////////////////////////////////////////////////////////////////////////////

Inheritance:
............


//shared property
class Product {
    constructor(id) {
        this.id = id;
    }
}
Product.prototype.price = 100;
Product.prototype.qty = 10;

class Computer extends Product {
    constructor(id = 0, name) {
        super(id)
        this.name = name;
    }
}


// var product = null;
// product = new Product(23);
// console.log(product.id, product.price, product.qty)

// product = new Product(34);
// console.log(product.id, product.price, product.qty)


var product = null;
product = new Computer(23);
console.log(product.id, product.price, product.qty)

product = new Computer(34);
console.log(product.id, product.price, product.qty)
/////////////////////////////////////////////////////////////////////////////////////////

Polymorphism:

Js does not support polymorphism like c++.

compile time polymorphism is supported in different way
runtime time polymorphism is supported in different way
   -"Scope Chain".

method redefining:
..................


class Account {
    constructor() {

    }
    //method
    deposit() {
        return 100.0;
    }
}
class SavingsAccount extends Account {
    constructor() {
        super();
    }
    //redefine method
    deposit() {
        return 1000.00 * super.deposit();
    }
}
var sb = new SavingsAccount();
console.log(sb.deposit())
////////////////////////////////////////////////////////////////////////////////////////////
static variables:

ES 6 supports static variables and methods


class Message {
    static SUCCESS = 'success';
    static WARNING = 'Warning';
    static FAILED = 'Failed'
    constructor() {

    }
    static doStuff(){
        return 'static variables'
    }
}
console.log(Message.SUCCESS,Message.doStuff())
//////////////////////////////////////////////////////////////////////////////////////////////

Object Destruturing:
....................

-functions and objects

1.how to pass objects as parameter to function.



//without object destructuring
// function printEmployee(employee) {
//     //print employee information
//     console.log(`Id ${employee.id}`)
//     console.log(`Name ${employee.name}`)
//     console.log(`Salary ${employee.salary}`)
// }
//with object destructuring
// function printEmployee(employee) {
//     //print employee information
//     //destructuring syntax
//     var { id, name, salary } = employee;
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`Salary ${salary}`)
// }

// function printEmployee({ id, name, salary }) {
//     //print employee information
//     //destructuring syntax
//     //    var { id, name, salary } = employee;
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`Salary ${salary}`)
// }
var printEmployee = ({ id, name, salary }) => {
    //print employee information
    //destructuring syntax
    //    var { id, name, salary } = employee;
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`Salary ${salary}`)
};
var employee = {
    id: 1,
    name: 'subramanian',
    salary: 2000
};
printEmployee(employee);


nested object destructuring:
............................
var printEmployee = ({ id, name, salary, address: { city } }) => {
    //print employee information
    //destructuring syntax
    //    var { id, name, salary,address:{city} } = employee;
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`Salary ${salary}`)
    // console.log(`City  ${address.city}`)
    console.log(`City  ${city}`)

};

var employee = {
    id: 1,
    name: 'subramanian',
    salary: 2000,
    address: {
        city: 'Coimbatore'
    }
};
printEmployee(employee);
//////////////////////////////////////////////////////////////////////////////////////////////

How to return object with dynamic values with help of destructuring...

//

// function getStock() {
//     return {
//         id: 1,
//         symbol: 'GOOGLE',
//         qty: 100,
//         price: 1000
//     };
// }
// console.log(getStock())

// function getStock(id = 1, symbol = 'GOOGLE', qty = 100, price = 1000) {
//     return {
//         id: id,
//         symbol: symbol,
//         qty: qty,
//         price: price
//     };
// }
//destructuring
// function getStock(id = 1, symbol = 'GOOGLE', qty = 100, price = 1000) {
//     //if key:locavariable is same- key:value is same, make it one
//     return {
//         id,
//         symbol,
//         qty,
//         price
//     };
// }
var getStock = (id = 1, symbol = 'GOOGLE', qty = 100, price = 1000) => ({
    id,
    symbol,
    qty,
    price
});

console.log(getStock())
console.log(getStock(2, 'MICROSOFT', 10000, 1900))
////////////////////////////////////////////////////////////////////////////////////////////
ES 6 class properties destructuring:
....................................

class TodoService {
    constructor() {

    }
    findAll() {
        return 'findAll todos'
    }
    save() {
        return 'save todos'
    }
    remove() {
        return 'remove todos'
    }
    update() {
        return 'update todos'
    }
}
var todo = new TodoService();
console.log(todo.findAll(), todo.save(), todo.remove(), todo.update());

var { findAll, save, remove, update } = new TodoService();
console.log(findAll(), save(), remove(), update());

////////////////////////////////////////////////////////////////////////////////////////////

methods inside literal object using destructuring
.................................................


var config = {
    setConfig: function () {
        return 'config'
    },
    //es 6 syntax
    setNewConfig() {
        return 'new Config'
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////
                                        Objects
//////////////////////////////////////////////////////////////////////////////////////////////

Types of Objects:

1.custom objects : created by programmers using constructors,literals
2.builtin object :many objects are provided by javascript language.


Builtin Objects:

Types of builtin objects

1.POJO -  plan old javascript objects
2.DOM Objects - related to HTML and browser objects


POJOS:
......
1.Object
2.Wrapper Objects
3.Math
4.Date
5.Array
6.JSON
7.Promise
8.XHR
9.Websocket
etc...

1.Object:

-Object is core meta object in javascript.
-Object is super most parent class in javascript,methods , properties defined in this will be 
 available in all objects.
-Object provides some very usefull utility methods.

how to create object?
 with help of function/class/literals
 without these can we object?
  yes , you by calling Object class Constructor.


//object creations

//1
function Employee() {

}
var emp = new Employee()

//2.
class Customer {

}
var cust = new Customer();

//3
var product = {
    id: 1
}

//4
var stock = new Object();
stock.id = 1;
stock.symbol = 'google';
console.log(stock.id, stock.symbol)

methods: instance methods,static


//object creations

Object.prototype.toString = function(){
    return `My object`
}

//1
function Employee() {

}
var emp = new Employee()
console.log(emp.toString())

//2.
class Customer {

}
var cust = new Customer();
console.log(cust.toString())

//3
var product = {
    id: 1
}
console.log(product.toString())

//4
var stock = new Object();
stock.id = 1;
stock.symbol = 'google';
console.log(stock.id, stock.symbol)

static methods:
...............
//object class usefull methods

//Object.assign- return new object; immutablity

function updateProfile(city, profile) {

    //profile.city = city:cloning process from profile to {}
    return Object.assign({}, profile, { city })
}
var profile = {
    id: 1,
    name: 'ram',
    city: 'delhi'
}
var res = null
res = updateProfile('coimbatore', profile)
console.log(res);
////////////////////////////////////////////////////////////////////////////////////////////////
In general objects are modifiable, what if i want to restrict that?

-update restrictions
-remove restrictions
-add restrictions


//stop updating
var emp = {
    id: 1,
    name: 'subramanian',
    city: 'coimbatore'
}
Object.defineProperty(emp, 'id', {
    writable: false
});
console.log('before update')
console.log(emp)
emp.id = 90;
console.log('after update')
console.log(emp)
//how to prevent adding new properties
var cust = {
    id: 1,
    name: 'subramanian'
};
console.log('before add')
console.log(cust)
Object.freeze(cust);
console.log('after add')
cust.city = 'coimbatore'
console.log(cust)

//how to prevent deleting any properties 
var stock = {
    id: 1,
    value: 100,
    qty: 900
}
Object.seal(stock);
console.log('before delete')
console.log(stock)
delete stock.qty;
console.log('after delete')
console.log(stock)
////////////////////////////////////////////////////////////////////////////////////////////

Wrapper objects:
 In js everything is object including numbers,strings,booleans,function.

Wrapper Object is representation of primitives values.

Why wrapper Objects?
 For performing some very usefull operations.

How to create string object?

var a ="hello" //object is created internally
var a = new String("hello") - js never recommends this pattern.

String Object and its methods:
..............................

//strings
//length property
var str = 'Life, the universe and everything. Answer:';

console.log(`${str} ${str.length}`);
console.log(`The character at index ${4} is ${str.charAt(4)}`);

str = 'The quick brown fox jumps over the lazy dog.';

var words = str.split(' ');
console.log(words)
console.log(str.toUpperCase())
//////////////////////////////////////////////////////////////////////////////////////////
Number:
Number is a primitive wrapper object used to represent and manipulate numbers like 37 or -9.25.

The Number constructor contains constants and methods for working with numbers. Values of other types can be converted to numbers using the Number() function

Number provides

1.function syntax
   Number('10') -> 10 - conversion.

2.constructor syntax
  new Number() - new number object; not recommended in order to represent numbers.

//Number

//static properties
console.log(`Max Value ${Number.MAX_VALUE}`)
console.log(`Min Value ${Number.MIN_VALUE}`)
console.log(`Negative infinity ${Number.NEGATIVE_INFINITY}`)
console.log(`Postive infinity ${Number.POSITIVE_INFINITY}`)
console.log(`NaN Value ${Number.NaN}`)
//static methods
var x = 100;
var y;
var res = x * y;
if (Number.isNaN(res)) {
    console.log('something went wrong')
} else {
    console.log('ok')
}
//instance methods
//var n = new Number(100);
var n = 100.8956; //new Number(1000.8956)
console.log(`Round off ${n.toFixed()} ${n.toFixed(2)}`)
console.log(`Exponential ${n.toExponential(2)}`)

////////////////////////////////////////////////////////////////////////////////////////

Boolean:
 The Boolean object is an object wrapper for a boolean value.

//Boolean Object

var b = true;
console.log(b.toString())
var myFalse = new Boolean(false);
console.log(myFalse.valueOf())
//////////////////////////////////////////////////////////////////////////////////////////////
Math:
Math is a built-in object that has properties and methods for mathematical constants and functions. It’s not a function object , so that you cant use new keyword to create object.


//Math Object
//static properties
console.log(`PI ${Math.PI}`)
console.log(`PI ${Math.PI.toFixed(3)}`)
//static methods
console.log(`Random Number ${Math.random()}`)
console.log(`Round ${Math.round(0.3)}`)
console.log(`Round ${Math.round(Math.random().toFixed(4))}`)

//
function random(min, max) {
    const num = Math.floor(Math.random() * (max - min + 1)) + min;
    return num;
}

console.log(random(1, 10));
//////////////////////////////////////////////////////////////////////////////////////////////

Date:
JavaScript Date objects represent a single moment in time in a platform-independent format. Date objects contain a Number that represents milliseconds since 1 January 1970 UTC.


Date()
  When called as a function, returns a string representation of the current date and time, exactly as new Date().toString() does.
 you cant use date related api because it is string

new Date()
  When called as a constructor, returns a new Date object.
 you can use date related api

//Date 

//
var datestr = Date()
var dateobj = new Date();
console.log(`${typeof datestr}`)
console.log(`${typeof dateobj}`)
//static methods
console.log(`Current Time in Ms ${Date.now()} $ `)
console.log(`Parsed Date ${Date.parse('04 Dec 1995 00:12:00 GMT')}`)

//instance methods
var date = new Date();
console.log(` day of the month (1–31) ${date.getDate()}`)
console.log(` day of the week (0–6)   ${date.getDay()}`)
console.log(` the hour (0–23)    ${date.getHours()} hrs Mins ${date.getMinutes()}`)

//date conversion/formating
console.log(` Readable String Representation ${date.toDateString()}`)
console.log(` Readable String Representation ${date.toLocaleDateString()}`)

//Perfermance testing: How much time took for given operations

var start = Date.now();
for (var i = 0; i < 10000000000; i++) {

}
var end = Date.now();
var elapsed = end - start
console.log(`${elapsed} Time taken by for loop for 1000000000 iterations`)
//////////////////////////////////////////////////////////////////////////////////////////////

Array:
......

1.Array is object.
2.Array is 0th based index
3.Array is dynamic array list list
4.It provides lot of api to create most powerfull ds.

How to create array object?

1.using constructor
  new Array() - not recommended
2.using literal 
  []

//Array:

//create simple array
var list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
console.log(list)
var strlist = ["a", 'b', "c"];
console.log(strlist)
//collection of objects
var profiles = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
    { id: 3, name: 'c' },
    { id: 4, name: 'd' },
];
console.log(profiles);

class Product {
    constructor(id = 0, name = 'pname') {
        this.id = id;
        this.name = name;
    }
}
//list of products
var products = [
    new Product(1, 'p1'),
    new Product(2, 'p2'),
    new Product(3, 'p3'),
    new Product(4, 'p4'),
    new Product(5, 'p5')
];
console.log(products)

//mixed array
var mixed = ['a', 1, true, new Product(), { id: 1, name: 'test' }, function () { }];
console.log(mixed)

//nested arrays
var nested = [
    'a',
    [
        12, 10, 90
    ],
    'hello'

];
console.log(nested);

//
var data = [
    {
        title: "Main dishes",
        data: ["Pizza", "Burger", "Risotto"]
    },
    {
        title: "Sides",
        data: ["French Fries", "Onion Rings", "Fried Shrimps"]
    },
    {
        title: "Drinks",
        data: ["Water", "Coke", "Beer"]
    },
    {
        title: "Desserts",
        data: ["Cheese Cake", "Ice Cream"]
    }
];
console.log(data)
////////////////////////////////////////////////////////////////////////////////////////////
Array Common Operations:

1.Accessing array elements:
2.Add elements
3.updating 
4.remove

//

var list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

//read one element
console.log(list[0], list[9])
//get length of an array.
console.log(list.length)
//last element
console.log(list[list.length - 1])
//iterators: for loop
for (var i = 0; i < list.length; i++) {
    console.log(`i value ${list[i]}`)
}

//adding element at end of the array: push
var newList = [1, 2, 3];
console.log('before adding')
console.log(`length ${newList.length}`);
var newLength = newList.push(4, 5, 6, 7, 8)
console.log(`length ${newLength} ${newList}`);

//remove last element/ at end of the array: pop
console.log(`Removed element ${newList.pop()}`)

for (var i = 0; i < list.length; i++) {
    console.log(`Removed element ${list.pop()}`)
}
//remove first element /at begining of the array: shift
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
console.log(list.shift(), list, list.unshift(1000), list)

///update existing elements with new element
var fruits = ["Banana", "Orange", "Apple", "Mango"];
console.log('before update', fruits);
fruits[0] = "Kiwi"
console.log('After update', fruits);

var months = ['Jan', 'March', 'April', 'June'];
console.log(months)
console.log(months.splice(1, 0, 'Feb'));
console.log(months)

var animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

console.log(animals.slice(2));
console.log(animals.slice(2, 4));

//merging /concat arrays;

var todos = [{ id: 1, status: true, text: 'learn js' }]
var newtdos = [{ id: 2, status: false, text: 'learn node js' }]
var finaltodos= todos.concat(newtdos)
console.log(finaltodos);

/////////////////////////////////////////////////////////////////////////////////////////////

Array Advanced Operations:
..........................

1.sort:
//Array sorting
var list = [1, 30, 4, 21, 100000];
//
// list.sort(function (a, b) {
//     return a - b;
// // })
// list.sort((a, b) => {
//     return a - b;
// })

list.sort((a, b) => a - b)
console.log('asc', list)
list.sort((a, b) => b - a)
console.log('desc', list)

//objects sorting : objects are sorted based on keys of objects.
var items = [
    { name: 'Edward', value: 21 },
    { name: 'Sharpe', value: 37 },
    { name: 'And', value: 45 },
    { name: 'The', value: -12 },
    { name: 'Magnetic', value: 13 },
    { name: 'Zeros', value: 37 }
];
console.log('Objects before sort ing', items)
items.sort((a, b) => {
    return a.value - b.value
})
console.log('Objects after sort ing asc order', items)
//name based sorting
items.sort(function (a, b) {
    var nameA = a.name.toUpperCase(); // ignore upper and lowercase
    var nameB = b.name.toUpperCase(); // ignore upper and lowercase
    // return nameA.localeCompare(nameB)
    if (nameA < nameB) {
        return -1;
    }
    if (nameA > nameB) {
        return 1;
    }
    // names must be equal
    return 0;
});
console.log('Objects after sort ing asc order', items)
/////////////////////////////////////////////////////////////////////////////////////////////
Iterator:
  for... loop
 dont use for..loop use array.forEach method.

array.forEach(function(){});
1.it takes function as parameter which never returns any thing.

var doubleIt = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
//console.log(doubleIt)
// doubleIt.forEach(function(item,index){
//     console.log(item)
// });
doubleIt.forEach((item, index) => {
    console.log(item)
});


Transformation:
  iterating and changing elements in side array.

eg:
  i have list of numbers, i need to double them.

map

array.map(transfomer function)

1.map takes function, which returns element ,modified
2.map returns new array.

//array transformation

var doubleIt = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
console.log(doubleIt)
// var doubledArray = doubleIt.map(function (item) {
//     //logic
//     return item * 2;
// });
var doubledArray = doubleIt.map(item => item * 2);
console.log(doubledArray)

var strs = ["a", "b", "c", "d"];
var upperCase = strs.map(item => item.toUpperCase())
console.log(upperCase)
////////////////////////////////////////////////////////////////////////////////////////////

Predicate:
  Api will return new items based on true.

array.filter
//filter

var list = [10, 20, 33, 1, 5, 7, 8];

//find even numbers from the list
// var even = list.filter(function (i) {
//     return i % 2 === 0
// });
var even = list.filter(i => i % 2 === 0);
console.log(even)
var odd = list.filter(i => i % 2 !== 0);
console.log(odd)


find:
 The find() method returns the value of the first element in the provided array that satisfies the provided testing function,  if testing failed it returns undefined.


//find method.

var list = [1, 2, 3, 1, 4, 5];
var found = list.find(i => i == 1)
console.log(found)

var empList = [{
    id: 1,
    name: 'a'
},
{
    id: 2,
    name: 'b'
},
{
    id: 3,
    name: 'c'
}, {
    id: 4,
    name: 'd'
}
];

function findByid(id) {
    return empList.find(employee => {
        return id === employee.id
    });
}

var employee = findByid(1)
if (employee) {
    console.log(employee)
} else {
    console.log('No employee found!!')
}
/////////////////////////////////////////////////////////////////////////////////////////////

can we coimbine, map--filter?
 
//map--filter

var list = [1, 34, 56, 78, 2, 10,55];
//doubleIt-find even numbers.

list.map(i => i * 2).filter(i => i % 2 === 0).forEach(i => console.log(i));
console.log('......')
list.map(i => i * 3).filter(i => i % 2 !== 0).forEach(i => console.log(i));
..............................................................................................

                                  JSON  - Javascript Object Notation
                                     (Data interchange format)
..............................................................................................

what is json?
  JSON (JavaScript Object Notation) is a lightweight data-interchange format.
  Data interchange format is format used to exchange data between two different systems and   machines and os.

- It is easy for humans to read and write. It is easy for machines to parse and generate.
- It is simple ascii file.
- It is based on a subset of the JavaScript Programming Language Standard ECMA-262 3rd Edition   December 1999.
- JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others.

JSON will represent data in key value pair.

-key should be string-""
-value should be - string,number,boolean,object,array,null.

IS it json?
  {
   id:1
  }
it is not json but js object

  {
    "id":1
  }

in js literal object key:value

 var emp = {
   id:1
 }
what is typeof id?
 in literal object , type of key is always string,value type is decided based on literal

here id is always string, 1 is number
  

var emp = {
    id: 1,
    name: 'hello'
}
console.log(typeof emp);
emp = {
    "id": 1,
    "name": 'hello'
}
console.log(typeof emp);
//////////////////////////////////////////////////////////////////////////////////////////////

JSON Parser:
 
 It is program, used to convert --Object to String and String to Object.

json(string)-----C++ --parser----will convert json string into C++ Object.

Javascript language introduced json parser in the form of JSON parser object in ES 5.

JSON.parse() -  string to object
JSON.stringify - object to string.


var emp = {
    id: 1,
    name: 'hello'
}
console.log(typeof emp);
emp = {
    "id": 1,
    "name": 'hello'
}
console.log(typeof emp);
////////////////////////////////////////////////////////////////////////

var profiles = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
    { id: 3, name: 'c' },
    { id: 4, name: 'd' },
];
console.log(typeof profiles);
//object to string conversion
var profilesJson = JSON.stringify(profiles);
console.log(typeof profilesJson)
console.log(profiles)
console.log(profilesJson)
var profilesObj = JSON.parse(profilesJson);
console.log(typeof profilesObj)

////////////////////////////////////////////////////////////////////////////////////////////

Scope:
  -local 
  -global
  -hositing
  -block scope
  -strict mode and non strict mode
  -scope chain
  -this keyword
  -closure

What is scope?
  Scope: visibility of variables ,where it is visible

//variable is declare inside script
var message = 'hello'

function sayHello() {
//variable is declared inside function
    var name = 'subramanian'
    console.log(message)
    console.log(name)
}
sayHello()
console.log(message);

here name is local variable 
 local variable is available inside function only.

and message is global variable
  which is available across the program.

////////////////////////////////////////////////////////////////////////////////

index.js

//can we access the i and j before declaration.

console.log(i, j)

var i = 10;
var j = 30;

console.log(i, j)


output:
undefined undefined
10 30

how we can access the variables before declaration.

Js code has two stages:

1.declaration/creation stage
2.execution/initalization stage


Js engine has three pipelines:

1.source code transformer
 index.js---------parsedcode
2.compiler 
 parsed code ----- assembly
3.execution 
   assembly is loaded into cpu and memory


index.js -source code
console.log(i, j)

var i = 10;
var j = 30;

console.log(i, j)
     |
 parser 
   |

var i;
var j;
console.log(i, j)
i = 10;
j = 30;

console.log(i, j)
  
What is "hoisting"?
  moving up one level.


source code
sayHello();
//function declaration
function sayHello() {
    console.log('Hello')
}
sayHello()

parsed code: function hoisting

//function declaration
function sayHello() {
    console.log('Hello')
}

sayHello();

sayHello()

///////////////////////////////////////
//var hai=undefined
hai();

hai();
^

TypeError: hai is not a function

var hai = function () {
    console.log('hai');
};
hai();
//////////////////////////////////////////////////////////////////////////////////////////////

Hositing inside function:

source code:

index.js

function sayMessage(message) {
    if (message) {
        var name = 'foo'
        console.log(name);
    }
    console.log(name);
}
//sayMessage('hello')
sayMessage()

parsed code:


function sayMessage(message) {
    var name;
    if (message) {
        name='foo'
        console.log(name);
    }
    console.log(name);
}
//sayMessage('hello')
sayMessage()

////////////////////////////////////////////////////////////////////////////////////////////

Block scope :

 if any variable is delcared inside blocks  like if, loops, will not be available outside that scope. java,c,C++ supports block scope, but js does not support block scope directly.

What if i want block scope?

 -i dont want to access the variable outside the scope eg ; outside if...

Soultion 1: ES 5 
 -Via IIEF functions.
//with block scope ;using iife function
function sayHai(message) {
    (function () {
        if (message) {
            //block ;if 
            var name = 'foo'
        }
    })()
    console.log(name);
}
sayHai('hello')

console.log(name);
              ^

ReferenceError: name is not defined

-via es 6 solution ; let and const keyword

//block scope via es 6 let and const keywords

function sayHello(message) {
    if (message) {
        //block ;if 
       // let firstName = 'foo'
       const firstName = 'foo'
    }
    console.log(firstName);
}
sayHello('hello')
.....................................................................................

var vs let and const:

 var is not block scoped
 let and const are block scoped.

//block scope

console.log(a);

let  a =10;

//without block scope
function sayMessage(message) {
    if (message) {
        //block ;if 
        var name = 'foo'
    }
    console.log(name);
}
sayMessage('hello')
//with block scope ;using iife function
function sayHai(message) {
    (function () {
        if (message) {
            //block ;if 
            var name = 'foo'
        }
    })()
  //  console.log(name);
}
sayHai('hello')
//block scope via es 6 let and const keywords

function sayHello(message) {
    if (message) {
        //block ;if 
       // let firstName = 'foo'
       const firstName = 'foo'
    }
    console.log(firstName);
}
sayHello('hello')
/////////////////////////////////////////////////////////////////////////////////////////////

let vs const:

let is block scoped but can reinitalize the variable
const is block scoped but cant be reinitalized.

const is mostly recommened in large apps.

//let vs const

let a = 10;
console.log(a);
a = 20;
console.log(a);
const b =100;
console.log(b);
b=900;

///////////////////////////////////////////////////////////////////////////////////////////

Advanced scope:

Three scopes in general: Based on variable binding

let /var  x = 10; - binding

1.static scope /Lexical scope
2.dynamic scope
3.Augmented scope - deprecated

1.static scope:

Static scope

Definition 1: Static scope:
 a language implements static scope, if only by looking at the source code one can determine in which environment a binding is resolved.

static scope is other wise is called lexcial scope 

Environment:
	Every execution context has an associated lexical environment.

Execution context:
 To execute JS code and track its runtime evaluation, ECMAScript spec defines the concept of an execution context. Logically execution contexts are maintained using a stack (the execution context stack as we will see shortly), which corresponds to the generic concept of a call-stack.

Execution context: An execution context is a specification device that is used to track the runtime evaluation of the code.

There are several types of ECMAScript code: the global code, function code, eval code, and module code; each code is evaluated in its execution context.

Lexical environment:
   A lexical environment is a structure used to define association between identifiers appearing in the context with their values. 

Each environment can have a reference to an optional parent environment.

So an environment is a storage of variables, functions, and classes defined in a scope.


how to write code in js?

 index.js - file

  variables
  functions(){
     variables
     functions
   }
  class

global env: structure which holds all variables,functions, class.
 how to implement global env -  object-context- global context


Structure of Environent:

Technically, an environment is a pair, consisting of an environment record (an actual storage table which maps identifiers to values), and a reference to the parent (which can be null).

eg code :

let x = 10;
let y = 20;
 
function foo(z) {
  let x = 100;
  return x + y + z;
}
 
foo(30); // 150
/////////////////////////////////////////////////////////////////////////////////////////////

flow:

var a = 10;
var b = 20;

function foo() {
    var a = 100;
    console.log(`foo ${a}`);
    function bar() {
        var a = 200;
        console.log(`bar ${a}`);
        console.log(`b ${b}`);
       // console.log(`c ${c}`)
    }
    bar();
}
foo();

how its working:

 1. three envs are created - global env,foo env, bar env.
 2. global env has no parent.
 3. foo env parent is global env
 4. bar env parent is foo env.
 
when variable lookup starts first it sees in the current env, if not it lookups its parent and its parent so on until lookup is succeed if not, then it will throw error "not defined".
   -This is called as static scope /lexical scope.
//////////////////////////////////////////////////////////////////////////////////////////////

Dynamic scope:
..............
The dynamic scope specifically for variables is not widely used on practice today.

Definition : 
   Dynamic scope: a language implements dynamic scope, 
	if a "caller" defines an activation environment of a "callee".

caller =>Object
callee =>function

The object only decide "who is owner" of callee.

How to implement dynamic binding in js?
   
   "this" keyword.

Defintion:

 This value:

    "this" is builtin variable which always has value(object), assinged during runtime.
     in JavaScript "this" value is dynamically scoped
    "value of this" dynamically identified not in creation phase

Who supplies the value of this?

   The value of this is determined and provided exactly by the caller
   
   "The function binding is decided on object  dynamically".    

how to test dynamic binding?

-in browser
-in node

eg:
//

//sayHello belongs to which object
function sayHello(){
    return this; // this reprents object 
}
//owner of sayHello is decided when you call it-caller.
console.log(sayHello()); // here there is no sign of object obj.sayHello();

output:
Window

window is global object in browser. any thing you delcare inscript belongs to window only.

sayHello belong to whom?

1.By default , in browser sayHello belong to window.


strict mode and nonstrict mode:

Javascript was born in 10 days,it had lot of bugs. js carried those bugs in every version of
js.
ECMA team decided to disable some bad coding syntax.for that who introduced a mode 
-non safe mode  - will not disable anything.

-safe mode  -will disable some bad code syntaxs
good practice being in safe mode.

"safe mode is other wise called as strict mode".

  


Points:
1.in non strict mode , this bound to window , I mean sayHello
 is bound on window object by default. 
2.In strict mode, this bound is decided by us based on object 
  binding , meaning that function is free from any Object  binding default : this is recommended.

'use strict'; //enabling safe mode

//sayHello belongs to which object
function sayHello(){
    return this; // this reprents object 
}
console.log(sayHello());

//output 
undefined


Think: can "this" be bound with function "Creation phase"  
       or can "this" be available in lexical scope?
       or can "this" be available in static scope?
                  No!


Use case 1 : how to bind function dynamically  | how to initalze "this" dynamically"

How to call function on objects dynamically?

Function object provides  function binding apis
1.call
2.apply
3.bind


1.call

func.call([thisArg[, arg1, arg2, ...argN]])

The call() method calls a function with a given this value(owner) and arguments provided individually.

function getCordinate(...name) {
    console.log(`${name} => x is ${this.x} y ${this.y}`)
}
//getCordinate()
//owner
const map = {
    x: 1000,
    y: 3888
}
//bind owner
getCordinate.call(map, 'Google Map', 'google');
//new Owner
window.x = 90;
window.y = 89;
getCordinate.call(window, 'Browser', 'chrome')


2.apply method

func.apply(thisArg, [ argsArray])

The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object).

function getStocks(...stocks) {
    console.log(`${this.name}`)
    console.log(stocks);
}

const obj = {
    name: 'google'
};
getStocks.apply(obj, [10, 20, 30, 40, 45]);

3.bind

  let boundFunc = func.bind(thisArg[, arg1[, arg2[, ...argN]]])

   bind is similar to call and apply but it returns a new function, call and apply will invoke
 functions immediatly on object - eager, where as bind is lazy.

function increment() {
    return this.count++;
}
const CounterApp = {
    count: 0
}
const inc = increment.bind(CounterApp);

for (let i = 0; i < 10; i++) {
    console.log('counter', inc())
}
//////////////////////////////////////////////////////////////////////////////////////////

Advanced dynamic binding : 

how to understand function calls inside objects 

'use strict';

const training = {
    teach: function () {

        //inner function of the teach function
        function teachJS() {
            return this;
        }
        //call teach js
        console.log('teachJs Owner ',teachJS())
        //owner binding
        //console.log('teachJs Owner ',training.teachJS())
        console.log('teachJs Owner ', teachJS.call(training))

        //teach return value
        return this;
    }
}
console.log('teach Owner ', training.teach());

......................................................................................

Returning a function and decides owner:

'use strict';

const training = {
    teach: function () {
        // return function teachJS() {
        //     return this;
        // }
        return function () {
            return this;
        }
    }
}
const teachJs = training.teach()
console.log('teachJs owner ', teachJs());
console.log('teachJs changing owner ', teachJs.call(training));
/////////////////////////////////////////////////////////////////////////////////////////////

self and this conventions:


const training = {
    firstName: 'Subramanian',
    teach: function () {
        console.log('teach function', this.firstName)
        //inner function: i need to access firstName inside teachjs
        let self = this;
        function teachJs() {
            //console.log('teachJs function', this.firstName)
            console.log('teachJs function', self.firstName)
        }
        teachJs();
    }
}
training.teach();

when returning function;

const training = {
    firstName: 'Subramanian',
    teach: function () {
        console.log('teach function', this.firstName)
        //inner function: i need to access firstName inside teachjs
        let self = this;
        return function () {
            //console.log('teachJs function', this.firstName)
            console.log('teachJs function', self.firstName)
        }
    }
}
const teachJs = training.teach()
teachJs();

Arrow and this:

The owner of this is fixed lexcially/statically.

Whether code in strict or non strict mode.

'use strict';

const sayHello = () => {
    return this;
}
console.log(sayHello());

const training = {
    firstName: 'Subramanian',
    teach: function () {
        return () => {
            console.log(this.firstName)
        };
    }
}
const teachJs = training.teach();
teachJs();


const video = {
    genere: "Sc fi",
    list: ['a1', 'b1', 'c1'],
    findMovies() {
        var self = this;
        // this.list.forEach(function (movie, index) {
        //     console.log(self.genere, movie)
        // })
        this.list.forEach((movie, index) => {
            console.log(this.genere, movie)
        })
       
    }
};
video.findMovies();
//////////////////////////////////////////////////////////////////////////////////////////////

Async Programming:
..................

Process: -  Java,C++ - Runtimes:

  Multi threaded.

Process : js engine -browser / node

 Single Threaded.


how to implement async / non blocking arch:

1.select api which talks to kernal in blocking.
  eg:
   timers
   xhr
   websocket
   dom event apis

2.how to process data returned from kernal
  function - callback function. - function is passed as parameter


Styles of write async :

1.callback style -core style
2.Promise style - simplified version of callbacks
3.async await style - simplified version of promises.
 

Simple timer:
//async ; callback style

function delay(callback) {
    //async api
    setTimeout(callback, 5000,'Subramanian')
}
console.log('start')
delay((data) => {
    //logic
    console.log('hello using timer',data)
});
console.log('end')
/////////////////////////////////////////////////////////////////////////////////////////////
complex callbacks:


const getUser = (resolve, reject) => {
    //logic
    let user = { id: 1, name: 'admin' };
    //user = null;
    let error = { message: 'User not found' }
    if (user) {
        setTimeout(resolve, 1000, user);
    } else {
        setTimeout(reject, 1000, error)
    }
};

getUser(user => {
    console.log(user)
}, err => {
    console.log(err)
});




Callback chain / nested callbacks:

 "The output of one callback will be input to another callback".


const getUser = (resolve, reject) => {
    //logic
    let user = { id: 1, name: 'admin' };
    //user = null;
    let error = { message: 'User not found' }
    if (user) {
        setTimeout(resolve, 1000, user);
    } else {
        setTimeout(reject, 1000, error)
    }
};

const login = (user, resolve, reject) => {
    let status = 'login success'
    let error = 'login failed'
    if (user.name === 'admin') {
        setTimeout(resolve, 1000, status);
    } else {
        setTimeout(reject, 1000, error)
    }
};

const showPage = (status, resolve, reject) => {
    let page = 'Admin page'
    let error = 'Guest Page'
    if (status === 'login success') {
        setTimeout(resolve, 1000, page);
    } else {
        setTimeout(reject, 1000, error)
    }
};


getUser(user => {
    console.log('getUser is called')
    //call login method
    login(user, status => {
        console.log('login  is called')
        //show page is called
        showPage(status, page => {
            console.log('Page is called')
            console.log(page)
        }, err => {
            console.log(err)
        });
    }, err => {
        console.log(err)
    });
}, err => {
    console.log(err)
});


Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?


  "No" : This is what we call as "Callback hell".

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})
callback is other wise called as doom of pyrbid.


///////////////////////////////////////////////////////////////////////////////////////////

How to write better callback programming? or How to avoid callback hell?


In 2005, JQUERY team started with working complex callback patterns, they found callback
hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".


Promise is design pattern which hides complexity of callback patterns


SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

2012 E6 Commit introduced Promise as Object in javascript

features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async implementations.


Promise ES 6 implementation:

IN ES 6 promise Object.

Promise object creation:

1.using constructors
2.using factory apis - Promise.resolve=Promise.reject


Promise object has api:

1.promise.then
2.promise.catch
3.finally


Promise Factory eg:

//Promise object creation: Factory apis;

function getSuccess() {
    return Promise.resolve('Success');
}
function getFailure() {
    return Promise.reject('failed');
}
// const p = getSuccess();
// console.log(p);
// p.then(data => console.log(data));

const getUser = () => {
    let user = { id: 1, name: 'admin' };
    //user = null;
    if (user) {
        return Promise.resolve('User found')
    } else {
        return Promise.reject('User not Found')
    }
}


console.log('start')

getSuccess()
    .then(data => console.log(data));

getFailure()
    .catch(err => console.log(err))

getUser()
    .then(user => console.log(user))
    .catch(err => console.log(err));

console.log('end')
////////////////////////////////////////////////////////////////////////////////////////////

Create Promise object : using constructors:

//Promise Constructor api: if you have any existing callback based programming
//you can convert to Promise 

//traditional callback based
function delay(callback) {
    setTimeout(callback, 1000, "Hello Callback")
}

//
delay(data => console.log(data));

//Promise based ; convert existing delay with promises

function delayAsync() {
    //Promise constructor
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 2000, "Hello Promise")
    });
}
delayAsync()
    .then(data => console.log(data))
    .catch(err => console.log(err))
    .finally(() => console.log('done'))
//////////////////////////////////////////////////////////////////////////////////////////

Callback hell and Promise Solution:

const getUser = () => {
    //logic
    let user = { id: 1, name: 'admin' };
    //user = null;
    let error = { message: 'User not found' }
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, error)
        }
    });
};
const login = user => {
    let status = 'login success'
    let error = 'login failed'
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, status);
        } else {
            setTimeout(reject, 1000, error)
        }
    });

};
const showPage = status => {
    let page = 'Admin page'
    let error = 'Guest Page'

    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, page);
        } else {
            setTimeout(reject, 1000, error)
        }
    });

};


// getUser()
//     .then(user => {
//         console.log('get User is called')
//         login(user)
//             .then(status => {
//                 console.log('login is called')
//                 showPage(status)
//                     .then(page => {
//                         console.log('show page is called');
//                     })
//                     .catch(err => console.log(err))
//             })
//             .catch(err => console.log(err))
//     })
//     .catch(err => {
//         console.log(err);
//     })
//     .finally(() => console.log('done'));

//simplified version
// getUser()
//     .then(user => {
//         console.log('get User is called')
//         return login(user);
//     })
//     .then(status => {
//         console.log('login is called')
//         return showPage(status);
//     })
//     .then(page => {
//         console.log('show page is called');
//     })
//     .catch(err => {
//         console.log(err);
//     })
//     .finally(() => console.log('done'));

getUser()
    .then(user => login(user))
    .then(status => showPage(status))
    .then(page => console.log(page))
    .catch(err => console.log(err))
    .finally(() => console.log('done'));

//using destructuring syntax
const { log } = console;
getUser()
    .then(login)
    .then(showPage)
    .then(log)
    .catch(log)
    .finally(() => log('done'));
/////////////////////////////////////////////////////////////////////////////////////////////

Advanced Async Programming:

Promise.all

Let’s say we want many promises to execute in parallel and wait until all of them are ready.

For instance, download several URLs in parallel and process the content once they are all done.

The syntax is:

let promise = Promise.all([...promises...]);

Promise.all([
    new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
    new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
    new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(r => console.log(r)); 


Promise.race
Similar to Promise.all, but waits only for the first settled promise and gets its result (or error).

Promise.race([
    new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
    new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000)),
    new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(console.log); // 1
/////////////////////////////////////////////////////////////////////////////////////////////

Drawbacks in promises:

1.Promise are readable soultion for complex callback patterns.
  but it will introduce again code complexity with "thenable" statements.

ES 7 Proposed new soultion called :async await
  -It reduces code for promise consumptions.

async:
-async is keyword used infront of function declaration; async functions
-async function returns Promise by default.
--async ....await keywords makes more readable code- sync style of async code.

//async functions
const { log } = console;

async function getValue() {
    return 10; // return Promise.resolve(10)
}
console.log(getValue())
getValue()
    .then(log)
////////////////////////////////////////////////////////////////////////////////

//async ... await togther

const getUser = () => {
    //logic
    let user = { id: 1, name: 'admin' };
    //user = null;
    let error = { message: 'User not found' }
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, error)
        }
    });
};
const login = user => {
    let status = 'login success'
    let error = 'login failed'
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, status);
        } else {
            setTimeout(reject, 1000, error)
        }
    });

};
const showPage = status => {
    let page = 'Admin page'
    let error = 'Guest Page'

    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, page);
        } else {
            setTimeout(reject, 1000, error)
        }
    });

};
//process promise
async function main() {
    //using thenables
    getUser()
        .then(user => {
            console.log('get User is called')
        })
        .catch(err => {
            console.log(err);
        })
        .finally(() => console.log('done'));
    //using await 

    try {
        const user = await getUser();
        const status = await login(user);
        const page = await showPage(status);
        console.log(user, status, page);
    }
    catch (err) {
        console.log(err);
    }
    finally {
        console.log('done')
    }



}
main();
/////////////////////////////////////////////////////////////////////////////////////////////

Apis used using Promises:

1.fetch() api.
fetch() allows you to make network requests similar to XMLHttpRequest (XHR). The main difference is that the Fetch API uses Promises, which enables a simpler and cleaner API, avoiding callback hell and having to remember the complex API of XMLHttpRequest.

const { log } = console;

function findAllTodos() {
    const url = "https://jsonplaceholder.typicode.com/todos"
    return fetch(url);//promise
}
async function main() {
    // findAllTodos()
    //     .then(response => {
    //         return response.json();
    //     })
    //     .then(todos => log(todos))
    //     .catch(log)
    try {
        const response = await findAllTodos();
        const todos = await response.json();
        log(todos)
    }
    catch (err) {
        log(err)
    }
}
main();
//////////////////////////////////////////////////////////////////////////////////////////////
                                 Javascript Module Patterns
/////////////////////////////////////////////////////////////////////////////////////////////


Module design patterns:

1.how to break app into multiple files
2.after breaking how to share code among files.


JS ;
1. has no language level modular design for file loading ,linking , sharing

2.Javascript engine provides simple loader which can load one .js file at a time.

3.If file has linking with other file,that also should be loaded separtly.

How to solve this issue?

Via module design patterns.

1.Namespace design pattern : which is core design pattern helps to organize code sharing only
  ->how to encapsulate the code
 which uses js core concept called "literal object/iife)"
2.AMD
3.CJS
4.ES 6 Module design pattern
5.System
6.UMD

out of which only 2 designs are used in coding

1.commonjs - node js 
2.es 6 module  - both node js and browser - cant be used directly


commonjs

1.how to share code across files
code :
  variables having any literal
  functions
  classes
2.how to link files -linker and loaders

share and link cjs provides keywords

1.require('filename')

sharing code
2.exports,module.exports 



//code 
exports.firstName = 'Subramanian'
exports.lastName = 'Murugan';
exports.age = 18
exports.address = {
    city: 'coimbatore'
}
exports.skills = ['js', 'java', 'c++']
exports.isValid = function () {
    return true;
}
const result = require('./mylib')
console.log(result);
console.log(result.isValid())


exports vs module.exports

exports returns object
module.exports returns things as it is.


module.exports

const EmployeeService = require('./Employee');

class EmployeeService {
    constructor() {

    }
    findAll() {
        return 'find all'
    }
}
module.exports = EmployeeService;

/////////////////////////////////////////////////////////////////////////////////////////////

Es6 modules
  = amd + cjs

es 6 modules never work directly in node and browser
we need loader program.
loader is available in webpack tool

how to link files

import

how to share code

export, export default

info.js


export const firstName = 'Subramanian'
export const age =19
export const skills = ['js']
export const sayHello = ()=>'hello'

Todo.js

class Todo {
    constructor() {

    }
    findAll() {
        return 'todos'
    }
}
export default Todo;

index.js

import { firstName, age, skills, sayHello } from './info'
import Todo from './Todo'

console.log(firstName, age, skills, sayHello())
let todo = new Todo()
console.log(todo.findAll())


Tips:
 use webpack.
******************************************Thank you***********************************






















